local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Data_upvr = require(ReplicatedStorage.Modules.Core.Data)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

local Window = WindUI:CreateWindow({
    Title = "‚òÉÔ∏è Kaiju Hub | PVP ",
    Icon = "layout-list", 
    Author = "‚ùÑÔ∏è My Kaiju |  BlockSpin | I love You :D !",
    Folder = "MyKaijuHub",
    Size = UDim2.fromOffset(400, 350),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 200,
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

Window:Tag({
    Title = "plus ultra",
    Icon = "lock-keyhole",
    Color = Color3.fromHex("#F7D30A"),
    Radius = 13,
})

Window:Tag({
    Title = "v 0.9 Test",
    Color = Color3.fromHex("#646666"),
    Radius = 13,
})

Window:EditOpenButton({ Enabled = false })

local ScreenGui = Instance.new("ScreenGui")
local ToggleBtn = Instance.new("ImageButton")

ScreenGui.Name = "WindUI_Toggle"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

ToggleBtn.Size = UDim2.new(0, 50, 0, 50)
ToggleBtn.Position = UDim2.new(0, 20, 0.5, -25)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Image = "rbxassetid://125837038699764" -- ‡πÄ‡∏ô¬É‡πÄ‡∏ò‡∏ä‡πÄ‡∏ô¬à‡πÄ‡∏ô‚Ç¨‡πÄ‡∏ò‡∏Ö‡πÄ‡∏ò¬Ç ImageId ‡πÄ‡∏ò‚Ä¢‡πÄ‡∏ò‡∏ë‡πÄ‡∏ò‡∏á‡πÄ‡∏ô‚Ç¨‡πÄ‡∏ò‡∏ç‡πÄ‡∏ò¬á
ToggleBtn.Active = true
ToggleBtn.Draggable = true
ToggleBtn.Parent = ScreenGui

local opened = true

local function toggle()
    opened = not opened
    if Window.UI then
        Window.UI.Enabled = opened
    else
        Window:Toggle()
    end
end

ToggleBtn.MouseButton1Click:Connect(function()
    ToggleBtn:TweenSize(
        UDim2.new(0, 56, 0, 56),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Quad,
        0.12,
        true,
        function()
            ToggleBtn:TweenSize(
                UDim2.new(0, 50, 0, 50),
                Enum.EasingDirection.Out,
                Enum.EasingStyle.Quad,
                0.12,
                true
            )
        end
    )
    toggle()
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.G then
        toggle()
    end
end)

local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})
local CheaterTab = Window:Tab({Title = "CHEATER:", Icon = "user"})
CheaterTab:Section({Title="CHEATER :"})
local MiscTab = Window:Tab({Title = "MISC:", Icon = "warehouse"})
MiscTab:Section({Title="Misc Functions :"})
local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})
local WeaponTab = Window:Tab({Title = "Weapon Mods:", Icon = "crosshair"})
WeaponTab:Section({Title="Weapon Mods :"})
local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="üåê state :"})
local SettingsTab = Window:Tab({Title = "Settings", Icon = "settings"})
SettingsTab:Section({Title="Settings  :"})

local Automatic = false
local FireRate = 1500
local toolCache = {}

local function matchesTarget(name, target)
    name = name:lower()
    target = target:lower()
    return name:find(target) ~= nil or name:match("%d*_" .. target .. "_?%d*") ~= nil
end

local function applyAttributesSmart(gun)
    local prev = toolCache[gun]
    if prev and prev.FireRate == FireRate then return end

    local attrValue = gun:GetAttribute("fire_rate")
    if attrValue ~= nil then
        gun:SetAttribute("fire_rate", FireRate)
    end

    for _, child in ipairs(gun:GetDescendants()) do
        if (child:IsA("NumberValue") or child:IsA("IntValue")) and matchesTarget(child.Name, "fire_rate") then
            child.Value = FireRate
        end
    end

    toolCache[gun] = { FireRate = FireRate }
end

local function updateAllGuns()
    if Automatic then
        if LocalPlayer.Character then
            for _, tool in ipairs(LocalPlayer.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    applyAttributesSmart(tool)
                end
            end
        end
        for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                applyAttributesSmart(tool)
            end
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    if Automatic then
        updateAllGuns()
    end
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and Automatic then
            applyAttributesSmart(child)
        end
    end)
end)

LocalPlayer.Backpack.ChildAdded:Connect(function(child)
    if child:IsA("Tool") and Automatic then
        applyAttributesSmart(child)
    end
end)

-- Weapon Tab UI
WeaponTab:Slider({
    Title = "Fire Rate",
    Flag = "KaijuFireRate",
    Value = { Min = 100, Max = 2000, Default = FireRate },
    Step = 1,
    Callback = function(value)
        pcall(function()
            FireRate = tonumber(value)
            updateAllGuns()
        end)
    end
})

WeaponTab:Toggle({
    Title = "Automatic",
    Flag = "KaijuAutomatic",
    Value = Automatic,
    Callback = function(state)
        pcall(function()
            Automatic = state
            if Automatic then
                updateAllGuns()
            end
        end)
    end
})

-- No Recoil System
local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)
getgenv().KaijuNoRecoil = false
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

local function EnableNoRecoil()
    if getgenv().KaijuNoRecoil then return end
    getgenv().KaijuNoRecoil = true

    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
    end

    if not antiLoop then
        antiLoop = task.spawn(function()
            while getgenv().KaijuNoRecoil do
                pcall(function()
                    local char = LocalPlayer.Character
                    local tool = char and char:FindFirstChildOfClass("Tool")
                    if tool and tool:GetAttribute("Recoil") then
                        tool:SetAttribute("Recoil", 0)
                    end
                    for _, gun in pairs(getgc(true)) do
                        if typeof(gun) == "table" and rawget(gun, "instance") and gun.instance then
                            gun.instance:SetAttribute("Recoil", 0)
                        end
                    end
                end)
                task.wait(0.3)
            end
            antiLoop = nil
        end)
    end
    print("‚úÖ No Recoil: ON")
end

local function DisableNoRecoil()
    if not getgenv().KaijuNoRecoil then return end
    getgenv().KaijuNoRecoil = false
    GunModule.apply_recoil = original_recoil
    if antiLoop then
        task.cancel(antiLoop)
        antiLoop = nil
    end
    print("‚ùå No Recoil: OFF")
end

local function ToggleNoRecoil(state)
    if state then EnableNoRecoil() else DisableNoRecoil() end
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Flag = "KaijuNoRecoil",
    Value = getgenv().KaijuNoRecoil,
    Callback = function(state)
        pcall(function()
            ToggleNoRecoil(state)
        end)
    end
})

-- Hit Aura System
WeaponTab:Section({Title="Auto Hit:"})
getgenv().KaijuHitAura = false
local autoLoop = nil

local function getActiveTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then return obj end
    end
    return nil
end

local function getPlayersInRange(radius)
    local inRange = {}
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
            and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then
                table.insert(inRange, p)
            end
        end
    end
    return inRange
end

local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = LocalPlayer.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            local CounterTable, SendRemote
            pcall(function()
                for _, Obj in ipairs(getgc(true)) do
                    if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
                        CounterTable = Obj
                        break
                    end
                end
                local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
                SendRemote = Remotes:WaitForChild("Send", 5)
            end)
            if CounterTable and SendRemote then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "melee_attack", tool, {target}, lookAtCFrame, 0.75)
                end)
            end
        end
    end
end

local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().KaijuHitAura do
            pcall(AttackNearby)
            task.wait(0.3)
        end
        autoLoop = nil
    end)
end

local function StopHitAura()
    getgenv().KaijuHitAura = false
    if autoLoop then
        task.cancel(autoLoop)
        autoLoop = nil
    end
end

local function ToggleHitAura(state)
    if state then
        getgenv().KaijuHitAura = true
        StartHitAura()
        print("‚úÖ Hit Aura: ON")
    else
        StopHitAura()
        print("‚ùå Hit Aura: OFF")
    end
end

WeaponTab:Toggle({
    Title = "Hit Aura",
    Flag = "KaijuHitAura",
    Value = getgenv().KaijuHitAura,
    Callback = function(state)
        pcall(function()
            ToggleHitAura(state)
        end)
    end
})

local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Value = false
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 150
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Value = 1000
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"
TargetPartValue.Parent = LocalPlayer

local AttackAntiLockEnabledValue = Instance.new("BoolValue")
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false
AttackAntiLockEnabledValue.Parent = LocalPlayer

local AttackAntiKillEnabledValue = Instance.new("BoolValue")
AttackAntiKillEnabledValue.Name = "AttackAntiKillEnabled"
AttackAntiKillEnabledValue.Value = false
AttackAntiKillEnabledValue.Parent = LocalPlayer

local IgnorePlayers = {}
local CurrentTarget, head, aimPos
local hue = 0

local GunNames = {"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9","Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 1
tracerLine.Visible = false

local PREDICTION_FACTOR = 0.165

local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end

    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)

    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end

    return prediction
end

-- AntiLockPrediction + Attack Anti Kill
local function AntiLockPrediction(part)
    if not part or not part.Parent then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    local humanoid = part.Parent:FindFirstChild("Humanoid")
    if not humanoid then return part.Position end

    local headPos = part.Position + Vector3.new(0, (part:IsA("BasePart") and part.Size.Y or 1)/2, 0)

    if AttackAntiKillEnabledValue.Value then
        return headPos
    end

    if AttackAntiLockEnabledValue.Value then
        local speed = root and root.Velocity.Magnitude or 0
        local factor = (speed >= 14) and 6 or 0
        local vel = root.Velocity
        local x = vel.X
        local z = vel.Z
        local dir = Vector3.new(0,0,0)
        if math.abs(x) > math.abs(z) then
            dir = Vector3.new((x>0 and 1 or -1)*factor,0,0)
        else
            dir = Vector3.new(0,0,(z>0 and 1 or -1)*factor)
        end
        return headPos + dir
    else
        return PredictPosition(part)
    end
end

local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = AntiLockPrediction(part)

            if MagicBulletValue.Value and (part and part.Parent and IsBehindWall(part)) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.05,0.05,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.new(1,1,1) -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
            game:GetService("Debris"):AddItem(beam, 1)

            task.delay(0.5, function()
                if beam and beam.Parent then
                    local hue = math.random()
                    beam.Color = Color3.fromHSV(hue, 1, 1)
                end
            end)
        end
    end
    return oldFire(self, unpack(args))
end)

RunService.RenderStepped:Connect(function()

    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1) -- FOV ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    CurrentTarget = target

    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromRGB(255,80,80) -- Tracer ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏≠‡πà‡∏≠‡∏ô‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

local SilentAimToggle = CombatTab:Toggle({
    Title = "Silent Aim",
    Flag = "SilentAimEnabled",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

local AttackAntiLockToggle = CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Flag = "AttackAntiLockEnabled",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
    end
})

local AttackAntiKillToggle = CombatTab:Toggle({
    Title = "Attack Anti Kill",
    Flag = "AttackAntiKillEnabled",
    Value = AttackAntiKillEnabledValue.Value,
    Callback = function(state)
        AttackAntiKillEnabledValue.Value = state
    end
})

CombatTab:Space()

-- FOV Slider
local FOVSlider = CombatTab:Slider({
    Title = "FOV :",
    Flag = "FOVRadius",
    Value = {Min = 10, Max = 1000, Default = 150},
    Step = 5,
    Callback = function(value)
        FOVRadiusValue.Value = value
        fovCircle.Radius = value
    end
})

-- Lock Distance Slider
local LockDistanceSlider = CombatTab:Slider({
    Title = "Lock Distance :",
    Flag = "LockDistance",
    Value = {Min = 50, Max = 3000, Default = 1000},
    Step = 25,
    Callback = function(value)
        LockDistanceValue.Value = value
    end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

local MagicBulletToggle = CombatTab:Toggle({
    Title = "Magic Bullet",
    Flag = "MagicBullet",
    Value = MagicBulletValue.Value,
    Callback = function(state)
        MagicBulletValue.Value = state
    end
})

-- Safe Players Multi Dropdown + Refresh
local function UpdatePlayerNames()
    local names = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            table.insert(names, plr.Name)
        end
    end
    return names
end

CombatTab:Space()

local safePlayersDropdown = CombatTab:Dropdown({
    Title = "üõ°Ô∏èSafe Players",
    Multi = true,
    AllowNone = true,
    Values = UpdatePlayerNames(),
    Value = {},
    Callback = function(selected)
        IgnorePlayers = {}
        for _, name in ipairs(selected) do
            table.insert(IgnorePlayers, name)
        end
        print("Safe Players Updated: " .. table.concat(IgnorePlayers, ", "))
    end
})

CombatTab:Button({
    Title = "üîÅSafe player List",
    Callback = function()
        local newValues = UpdatePlayerNames()
        safePlayersDropdown:SetValues(newValues)
        print("‚úÖ Player list refreshed")
    end
})

local function CreateBool(name)
    local val = Instance.new("BoolValue")
    val.Name = name
    val.Value = false
    val.Parent = LocalPlayer
    return val
end

local BoxEnabled = CreateBool("ESPBoxEnabled")
local NameEnabled = CreateBool("ESPNameEnabled")
local DistanceEnabled = CreateBool("ESPDistanceEnabled")
local HealthEnabled = CreateBool("ESPHealthEnabled")
local HighlightEnabled = CreateBool("ESPHighlightEnabled")
local TracerEnabled = CreateBool("ESPTracerEnabled")

-- Toggle ‡∏ó‡∏∏‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
EspTab:Toggle({Title = "Box", Value = BoxEnabled.Value, Callback = function(state) BoxEnabled.Value = state end})
EspTab:Toggle({Title = "Name", Value = NameEnabled.Value, Callback = function(state) NameEnabled.Value = state end})
EspTab:Toggle({Title = "Distance", Value = DistanceEnabled.Value, Callback = function(state) DistanceEnabled.Value = state end})
EspTab:Toggle({Title = "Health", Value = HealthEnabled.Value, Callback = function(state) HealthEnabled.Value = state end})
EspTab:Toggle({Title = "Highlight", Value = HighlightEnabled.Value, Callback = function(state) HighlightEnabled.Value = state end})
EspTab:Toggle({Title = "Tracer", Value = TracerEnabled.Value, Callback = function(state) TracerEnabled.Value = state end})

-- ESP Storage
local espBoxes, espNames, espDistances, healthBars, highlights, tracerLines = {}, {}, {}, {}, {}, {}
local hue = 0

-- WorldToViewport
local function worldToViewport(pos)
    local screen, onScreen = Camera:WorldToViewportPoint(pos)
    return Vector2.new(screen.X, screen.Y), onScreen
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Box ESP
local function CreateBox(plr)
    if plr == LocalPlayer then return end
    if espBoxes[plr] then return end
    local lines = {}
    for i=1,12 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Color3.fromRGB(255,255,255)
        line.Thickness = 2
        line.Transparency = 1
        lines[i] = line
    end
    espBoxes[plr] = lines
end

local function RemoveBox(plr)
    if espBoxes[plr] then
        for _, line in ipairs(espBoxes[plr]) do line:Remove() end
        espBoxes[plr] = nil
    end
end

-- Name & Distance ESP
local function CreateNameDistance(plr)
    if plr == LocalPlayer or not plr.Character then return end

    -- Name
    local head = plr.Character:FindFirstChild("Head")
    if head then
        if NameEnabled.Value then
            local bill = head:FindFirstChild("NameESP")
            if not bill then
                bill = Instance.new("BillboardGui")
                bill.Name = "NameESP"
                bill.Adornee = head
                bill.Size = UDim2.new(0,120,0,25)
                bill.AlwaysOnTop = true
                bill.LightInfluence = 0
                bill.StudsOffset = Vector3.new(0,9.5,0)
                local label = Instance.new("TextLabel")
                label.Parent = bill
                label.Size = UDim2.new(1,0,1,0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.TextSize = 10
                label.TextColor3 = Color3.new(1,1,1)
                label.TextStrokeTransparency = 0
                label.TextStrokeColor3 = Color3.new(0,0,0)
                label.Text = plr.Name
                label.RichText = true
                bill.Parent = head
                espNames[plr] = bill
            else
                bill.Enabled = true
            end
        elseif espNames[plr] then
            espNames[plr].Enabled = false
        end
    end

    -- Distance
    local root = plr.Character:FindFirstChild("HumanoidRootPart")
    if root then
        local dist = math.floor((root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
        if DistanceEnabled.Value then
            local billData = espDistances[plr]
            if not billData then
                local bill = Instance.new("BillboardGui")
                bill.Name = "DistanceESP"
                bill.Adornee = root
                bill.Size = UDim2.new(0,80,0,20)
                bill.AlwaysOnTop = true
                bill.LightInfluence = 0
                bill.StudsOffset = Vector3.new(0,-9.5,0)
                local label = Instance.new("TextLabel")
                label.Parent = bill
                label.Size = UDim2.new(1,0,1,0)
                label.BackgroundTransparency = 1
                label.Font = Enum.Font.Gotham
                label.TextSize = 10
                label.TextColor3 = Color3.new(1,1,1)
                label.TextStrokeTransparency = 0
                label.TextStrokeColor3 = Color3.new(0,0,0)
                label.Text = "Distance: "..dist.."m"
                label.RichText = true
                bill.Parent = root
                espDistances[plr] = {bill=bill,label=label}
            else
                billData.label.Text = "Distance: "..dist.."m"
                billData.bill.Enabled = true
            end
        elseif espDistances[plr] then
            espDistances[plr].bill.Enabled = false
        end
    end
end

-- Health ESP
local function CreateHealth(plr)
    if plr == LocalPlayer or not plr.Character then return end
    local humanoid = plr.Character:FindFirstChild("Humanoid")
    local root = plr.Character:FindFirstChild("HumanoidRootPart")
    if humanoid and root and HealthEnabled.Value then
        if healthBars[plr] then return end
        local bar = Instance.new("BillboardGui")
        bar.Name = "HealthESP"
        bar.Adornee = root
        bar.Size = UDim2.new(0,30,0,3)
        bar.StudsOffset = Vector3.new(0,-5,0)
        bar.AlwaysOnTop = true
        bar.LightInfluence = 0
        local bg = Instance.new("Frame")
        bg.Size = UDim2.new(1,0,1,0)
        bg.BackgroundColor3 = Color3.fromRGB(0,0,0)
        bg.BorderSizePixel = 0
        bg.Parent = bar
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1,0,1,0)
        frame.BackgroundColor3 = Color3.fromRGB(144,238,144)
        frame.BorderSizePixel = 0
        frame.Parent = bg
        bar.Parent = plr.Character
        healthBars[plr] = {bar=bar,bg=bg,frame=frame,humanoid=humanoid}
    end
end

-- Highlight ESP
local function CreateHighlight(plr)
    if plr == LocalPlayer or not plr.Character then return end
    if HighlightEnabled.Value and not plr.Character:FindFirstChild("ESP_HIGHLIGHT") then
        local highlight = Instance.new("Highlight")
        highlight.Name = "ESP_HIGHLIGHT"
        highlight.FillColor = Color3.fromRGB(180,40,255)
        highlight.OutlineColor = Color3.fromRGB(255,255,255)
        highlight.FillTransparency = 0.2
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = plr.Character
        highlights[plr] = highlight
    elseif not HighlightEnabled.Value and highlights[plr] then
        highlights[plr]:Destroy()
        highlights[plr] = nil
    end
end

-- Tracer ESP
local function CreateTracer(plr)
    if plr == LocalPlayer or not plr.Character then return end
    if plr.Character:FindFirstChild("Head") and not tracerLines[plr] then
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Transparency = 1
        line.Color = Color3.fromHSV(hue,1,1)
        line.Visible = TracerEnabled.Value
        tracerLines[plr] = line
    end
end

-- Main update loop
RunService.RenderStepped:Connect(function()
    hue = (hue + 0.001)%1
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            -- Box
            if BoxEnabled.Value then
                if not espBoxes[plr] then CreateBox(plr) end
                local lines = espBoxes[plr]
                local char = plr.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local root = char.HumanoidRootPart
                    local scale = root.Size.Y
                    local corners = {
                        Vector3.new(-1,2,-1), Vector3.new(1,2,-1), Vector3.new(1,2,1), Vector3.new(-1,2,1),
                        Vector3.new(-1,-2,-1), Vector3.new(1,-2,-1), Vector3.new(1,-2,1), Vector3.new(-1,-2,1)
                    }
                    local screenCorners = {}
                    local allOnScreen = true
                    for i, offset in ipairs(corners) do
                        local worldPos = root.Position + (root.CFrame:VectorToWorldSpace(offset*scale))
                        local screenPos, onScreen = worldToViewport(worldPos)
                        screenCorners[i] = screenPos
                        if not onScreen then allOnScreen = false end
                    end
                    if allOnScreen then
                        local edges={{1,2},{2,3},{3,4},{4,1},{5,6},{6,7},{7,8},{8,5},{1,5},{2,6},{3,7},{4,8}}
                        for i,edge in ipairs(edges) do
                            lines[i].From = screenCorners[edge[1]]
                            lines[i].To = screenCorners[edge[2]]
                            lines[i].Visible = true
                        end
                    else
                        for _,line in ipairs(lines) do line.Visible = false end
                    end
                end
            elseif espBoxes[plr] then
                RemoveBox(plr)
            end

            -- Name & Distance
            CreateNameDistance(plr)

            -- Health
            CreateHealth(plr)
            if healthBars[plr] then
                local h = healthBars[plr]
                local humanoid = h.humanoid
                local percent = math.clamp(humanoid.Health/humanoid.MaxHealth,0,1)
                h.frame.Size = UDim2.new(percent,0,1,0)
                if percent>0.5 then h.frame.BackgroundColor3 = Color3.fromRGB(144,238,144)
                elseif percent>0.25 then h.frame.BackgroundColor3 = Color3.fromRGB(255,255,102)
                else h.frame.BackgroundColor3 = Color3.fromRGB(255,102,102) end
                h.bar.Enabled = HealthEnabled.Value
            end

            -- Highlight
            CreateHighlight(plr)

            -- Tracer
            CreateTracer(plr)
            if tracerLines[plr] and plr.Character:FindFirstChild("Head") then
                local headPos = plr.Character.Head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
                local line = tracerLines[plr]
                line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Color = Color3.fromHSV(hue,1,1)
                line.Visible = TracerEnabled.Value and onScreen
            end
        else
            -- ‡∏•‡∏ö ESP ‡∏Ç‡∏≠‡∏á LocalPlayer
            RemoveBox(plr)
            if espNames[plr] then espNames[plr]:Destroy(); espNames[plr]=nil end
            if espDistances[plr] then espDistances[plr].bill:Destroy(); espDistances[plr]=nil end
            if healthBars[plr] then healthBars[plr].bar:Destroy(); healthBars[plr]=nil end
            if highlights[plr] then highlights[plr]:Destroy(); highlights[plr]=nil end
            if tracerLines[plr] then tracerLines[plr]:Remove(); tracerLines[plr]=nil end
        end
    end
end)

EspTab:Divider()
EspTab:Section({Title="Esp item:"})

local ItemESP_Enabled = false
local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

local RARITY_COLORS = {
    ["Common"] = Color3.fromRGB(230, 224, 224),
    ["Uncommon"] = Color3.fromRGB(200, 230, 200),
    ["Rare"] = Color3.fromRGB(160, 200, 255),
    ["Epic"] = Color3.fromRGB(200, 160, 255),
    ["Legendary"] = Color3.fromRGB(255, 200, 120),
    ["Omega"] = Color3.fromRGB(255, 120, 120),
}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á key ‡∏Ç‡∏≠‡∏á Tool
local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id") or tool:GetAttribute("WeaponId") or tool:GetAttribute("GunId")
    if itemId and itemId ~= "" then
        return "ITEMID_" .. tostring(itemId)
    end

    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureId or "NOTEX"))
        elseif part:IsA("MeshPart") and part.MeshId and part.MeshId ~= "" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureID or "NOTEX"))
        elseif part:IsA("Decal") and part.Texture and part.Texture ~= "" then
            table.insert(partsData, "DECAL_"..part.Texture)
        end
    end

    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end

    local displayName = tool:GetAttribute("DisplayName") or tool.Name
    local toolName = tool.Name
    local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"
    local imageId = tool:GetAttribute("ImageId") or "NOIMAGE"
    return "NAME_" .. displayName .. "_" .. toolName .. "_" .. rarity .. "_" .. imageId
end

-- ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô Tool ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end

        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        if imageId and imageId ~= "" and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                pcall(function()
                    ContentProvider:PreloadAsync({imageId})
                end)
            end)
        end
    end
end

pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end
    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end
    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local key = generateUniqueKey(tool)
    return WeaponDB[key]
end

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
local function createBillboardForPlayer(player)
    if player == LocalPlayer then return end

    local function updateESP()
        if not ItemESP_Enabled or not player.Character then return end

        local currentTools = {}
        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") and tool.Name ~= "Fists" then
                    local info = getWeaponInfo(tool)
                    if info then
                        table.insert(currentTools, info)
                    end
                end
            end
        end

        scan(player.Character)
        local backpack = player:FindFirstChild("Backpack")
        if backpack then scan(backpack) end

        -- ‡∏ñ‡πâ‡∏≤ Billboard ‡∏´‡∏≤‡∏¢‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
        if not BillboardCache[player] or not BillboardCache[player].Parent then
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ItemESP"
            billboard.Adornee = hrp
            billboard.Size = UDim2.new(0, 280, 0, 40)
            billboard.StudsOffset = Vector3.new(0, -6.5, 0)
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.Parent = hrp

            local container = Instance.new("Frame", billboard)
            container.Size = UDim2.new(1,0,1,0)
            container.BackgroundTransparency = 1

            BillboardCache[player] = billboard
        end

        -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Tool ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô Billboard
        local container = BillboardCache[player]:FindFirstChildOfClass("Frame")
        if container then
            container:ClearAllChildren()
            local layout = Instance.new("UIGridLayout")
            layout.CellSize = UDim2.new(0,35,0,35)
            layout.CellPadding = UDim2.new(0,6,0,0)
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Parent = container

            for i, info in ipairs(currentTools) do
                local img = Instance.new("ImageLabel")
                img.Parent = container
                img.Size = UDim2.new(0,35,0,35)
                img.BackgroundTransparency = 1
                img.Image = info.ImageId or "rbxassetid://7072725737"
                img.ScaleType = Enum.ScaleType.Fit
                img.LayoutOrder = i
                local color = RARITY_COLORS[info.Rarity] or Color3.fromRGB(255,255,255)
                img.ImageColor3 = color:Lerp(Color3.new(1,1,1),0.35)
            end
        end
    end

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    task.spawn(function()
        while ItemESP_Enabled and player.Parent do
            pcall(updateESP)
            task.wait(1)
        end
    end)

    -- ‡πÄ‡∏Å‡πá‡∏ö connection
    ItemESP_UpdateConnections[player] = {}
    if player.Character then
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildAdded:Connect(function()
            if ItemESP_Enabled then task.defer(updateESP) end
        end))
        table.insert(ItemESP_UpdateConnections[player], player.Character.ChildRemoved:Connect(function()
            if ItemESP_Enabled then task.defer(updateESP) end
        end))
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô (‡∏™‡∏£‡πâ‡∏≤‡∏á Billboard ‡πÉ‡∏´‡∏°‡πà‡∏ñ‡πâ‡∏≤‡∏´‡∏≤‡∏¢)
local function UpdateAllItemESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local hasBillboard = BillboardCache[player] and BillboardCache[player].Parent
            if ItemESP_Enabled and (not hasBillboard) then
                createBillboardForPlayer(player)
            end
        end
    end
end

-- Loop ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(1)
        UpdateAllItemESP()
    end
end)

-- Loop ‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä Billboard ‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(20)
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and ItemESP_Enabled then
                if BillboardCache[player] and BillboardCache[player].Parent then
                    BillboardCache[player]:Destroy()
                    BillboardCache[player] = nil
                end
                createBillboardForPlayer(player)
            end
        end
    end
end)

-- Player Added/Removed
Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer and ItemESP_Enabled then
        task.wait(0.1)
        createBillboardForPlayer(p)
    end
end)
Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then
        BillboardCache[p]:Destroy()
        BillboardCache[p] = nil
    end
    if ItemESP_UpdateConnections[p] then
        for _, conn in pairs(ItemESP_UpdateConnections[p]) do
            if conn.Connected then conn:Disconnect() end
        end
        ItemESP_UpdateConnections[p] = nil
    end
end)

EspTab:Toggle({
    Title = "Item",
    Value = ItemESP_Enabled,
    Callback = function(state)
        ItemESP_Enabled = state
        if state then
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LocalPlayer then
                    createBillboardForPlayer(p)
                end
            end
        else
            for p, billboard in pairs(BillboardCache) do
                if billboard then billboard:Destroy() end
            end
            BillboardCache = {}
            for player, conns in pairs(ItemESP_UpdateConnections) do
                for _, conn in pairs(conns) do
                    if conn.Connected then conn:Disconnect() end
                end
                ItemESP_UpdateConnections[player] = nil
            end
        end
    end
})
      
local player = Players.LocalPlayer      
local camera = Workspace.CurrentCamera      
      
local ItemESP_Enabled = false  -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î ESP      
local ESP_Items = {}  -- ‡πÄ‡∏Å‡πá‡∏ö Highlight + Drawing ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏≠‡πÄ‡∏ó‡∏°      

-- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°
local ITEM_COLORS = {
    ["Uzi"] = Color3.fromRGB(0, 170, 255),       -- ‡∏ü‡πâ‡∏≤
    ["Hunting"] = Color3.fromRGB(0, 170, 255),   
    ["Glock"] = Color3.fromRGB(0, 170, 255),    
    ["Sawnoff"] = Color3.fromRGB(0, 170, 255),  
    ["P226"] = Color3.fromRGB(0, 170, 255),     

    ["C9"] = Color3.fromRGB(0, 255, 0),         -- ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß
    ["G3"] = Color3.fromRGB(0, 255, 0),         

    ["M24"] = Color3.fromRGB(180, 0, 255),      -- ‡∏°‡πà‡∏ß‡∏á
    ["Double Draco"] = Color3.fromRGB(180, 0, 255),  

    ["Remington"] = Color3.fromRGB(255, 215, 0), -- ‡∏ó‡∏≠‡∏á
    ["AK47"] = Color3.fromRGB(255, 215, 0),     
    ["MP5"] = Color3.fromRGB(255, 215, 0),     
    ["RPG"] = Color3.fromRGB(255, 215, 0)      
}

local DEFAULT_HIGHLIGHT_COLOR = Color3.fromRGB(255, 255, 255)  -- ‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
local DEFAULT_TEXT_COLOR = Color3.fromRGB(255, 255, 255)  

-- ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å
local droppedFolder = Workspace:FindFirstChild("DroppedItem") or Workspace:FindFirstChild("DroppedItems")      
if not droppedFolder then      
    warn("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå DroppedItem / DroppedItems")      
    return      
end      

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠
local function getItemColor(itemName)
    for key, color in pairs(ITEM_COLORS) do
        if string.find(itemName, key) then
            return color
        end
    end
    return DEFAULT_HIGHLIGHT_COLOR
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡πÉ‡∏´‡πâ‡πÑ‡∏≠‡πÄ‡∏ó‡∏° 1 ‡∏ä‡∏¥‡πâ‡∏ô      
local function createItemESP(item)      
    if not ItemESP_Enabled then return end      
    if ESP_Items[item] then return end      
    if item.Name == "Money" then return end      
    if not item:FindFirstChild("Handle") and not item.PrimaryPart then return end      

    local handle = item:FindFirstChild("Handle") or item.PrimaryPart      
    local color = getItemColor(item.Name)
      
    -- Highlight      
    local highlight = Instance.new("Highlight")      
    highlight.FillColor = color      
    highlight.OutlineColor = color      
    highlight.FillTransparency = 0.3      
    highlight.OutlineTransparency = 0      
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop      
    highlight.Parent = item      
      
    -- ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°      
    local nameText = Drawing.new("Text")      
    nameText.Size = 7      
    nameText.Color = color      
    nameText.Center = true      
    nameText.Outline = true      
    nameText.Font = 2      
    nameText.Visible = true      
    nameText.Text = item.Name      
      
    -- ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á      
    local distanceText = Drawing.new("Text")      
    distanceText.Size = 7      
    distanceText.Color = DEFAULT_TEXT_COLOR      
    distanceText.Center = true      
    distanceText.Outline = true      
    distanceText.Font = 2      
    distanceText.Visible = true      
      
    ESP_Items[item] = {highlight = highlight, name = nameText, distance = distanceText, handle = handle, color=color}      
      
    -- ‡∏•‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏´‡∏≤‡∏¢      
    item.AncestryChanged:Connect(function()      
        if not item.Parent then      
            if ESP_Items[item] then      
                highlight:Destroy()      
                nameText:Remove()      
                distanceText:Remove()      
                ESP_Items[item] = nil      
            end      
        end      
    end)      
end      

-- ‡πÄ‡∏õ‡∏¥‡∏î ESP
local function enableItemESP()      
       end      
    end      
})

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å
local droppedFolder = Workspace:FindFirstChild("DroppedItem") or Workspace:FindFirstChild("DroppedItems")
if not droppedFolder then
    warn("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå DroppedItem / DroppedItems")
    return
end

local MoneyESP_Enabled = false
local ESP_Money = {}

local MONEY_HIGHLIGHT_COLOR = Color3.fromRGB(0,255,0)
local MONEY_NAME_COLOR = Color3.fromRGB(0,255,0)

local function createMoneyESP(item)
    if not MoneyESP_Enabled then return end
    if ESP_Money[item] then return end
    if item.Name ~= "Money" then return end
    local handle = item:FindFirstChild("Handle") or item.PrimaryPart or item:FindFirstChildOfClass("Part")
    if not handle then return end

    local highlight = Instance.new("Highlight")
    highlight.FillColor = MONEY_HIGHLIGHT_COLOR
    highlight.OutlineColor = MONEY_HIGHLIGHT_COLOR
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = item

    local nameText = Drawing.new("Text")
    nameText.Size = 7
    nameText.Color = MONEY_NAME_COLOR
    nameText.Center = true
    nameText.Outline = true
    nameText.Font = 2
    nameText.Visible = true
    nameText.Text = item.Name

    ESP_Money[item] = {highlight = highlight, name = nameText, handle = handle}

    item.AncestryChanged:Connect(function()
        if not item.Parent and ESP_Money[item] then
            highlight:Destroy()
            nameText:Remove()
            ESP_Money[item] = nil
        end
    end)
end

local function enableMoneyESP()
    MoneyESP_Enabled = true
    for _, item in pairs(droppedFolder:GetChildren()) do
        createMoneyESP(item)
    end
end

local function disableMoneyESP()
    MoneyESP_Enabled = false
    for item, data in pairs(ESP_Money) do
        if data.highlight then data.highlight:Destroy() end
        if data.name then data.name:Remove() end
    end
    ESP_Money = {}
end

RunService.Heartbeat:Connect(function()
    if not MoneyESP_Enabled then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    for item, data in pairs(ESP_Money) do
        if item and item.Parent and data.handle and data.handle.Parent then
            local worldPos = data.handle.Position + Vector3.new(0,2,0)
            local screenPos, onScreen = camera:WorldToViewportPoint(worldPos)
            if onScreen then
                data.name.Position = Vector2.new(screenPos.X, screenPos.Y)
                data.name.Visible = true
            else
                data.name.Visible = false
            end
        else
            if data.highlight then data.highlight:Destroy() end
            if data.name then data.name:Remove() end
            ESP_Money[item] = nil
        end
    end
end)

droppedFolder.ChildAdded:Connect(function(item)
    task.wait(0.5)
    createMoneyESP(item)
end)

EspTab:Toggle({
    Title = "Money",
    Value = MoneyESP_Enabled,
    Callback = function(state)
        if state then enableMoneyESP() else disableMoneyESP() end
    end
})

local placeId = game.PlaceId
local jobInput = ""
local TargetPlayers = 22
local PlaceIdForHop = 104715542330896


local statsButton = ServerTab:Button({
    Title = "<font color=\"rgb(255,0,0)\">Ping : 0ms</font> | <font color=\"rgb(0,255,0)\">FPS : 0</font> | <font color=\"rgb(0,170,255)\">Players : 0</font>",
    Callback = function()
        -- ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î
    end
})

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ä‡πà‡∏ß‡∏¢‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì FPS
local lastTime = tick()
local frameCount = 0
local fps = 0

RunService.RenderStepped:Connect(function()
    -- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì FPS
    frameCount = frameCount + 1
    local now = tick()
    if now - lastTime >= 1 then
        fps = frameCount
        frameCount = 0
        lastTime = now
    end

    -- ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏¥‡∏á
    local ping = math.floor(LocalPlayer:GetNetworkPing() * 1000)

    -- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
    local playerCount = #Players:GetPlayers()

    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Title ‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏°
    if statsButton and statsButton.SetTitle then
        statsButton:SetTitle(
            "<font color=\"rgb(255,0,0)\">Ping : "..ping.."ms</font> | "..
            "<font color=\"rgb(0,255,0)\">FPS : "..fps.."</font> | "..
            "<font color=\"rgb(0,170,255)\">Players : "..playerCount.."</font>"
        )
    end
end)

ServerTab:Section({Title = "üíªServer state :"})
ServerTab:Code({
    Title = "Server Id :",
    Code = [[ServerId : ]] .. game.JobId
})

-- ‡∏õ‡∏∏‡πà‡∏° Copy JobId
ServerTab:Button({
    Title = "Copy serverId",
    Callback = function()
        setclipboard(game.JobId)
        print("Copied JobId:", game.JobId)
    end
})

-- Input ‡πÉ‡∏™‡πà JobId
ServerTab:Input({
    Title = "üåêJobId :",
    Placeholder = "‡πÉ‡∏™‡πà ID",
    Callback = function(text)
        jobInput = text
    end
})

-- ‡∏õ‡∏∏‡πà‡∏° Join JobId
ServerTab:Button({
    Title = "üéÆJoin JobId",
    Callback = function()
        if jobInput ~= "" then
            TeleportService:TeleportToPlaceInstance(placeId, jobInput, LocalPlayer)
        else
            warn("‡πÉ‡∏™‡πà JobId ‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
        end
    end
})

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
local function GetServers(cursor)
    local url = ("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Desc&limit=100%s"):format(
        PlaceIdForHop,
        cursor and ("&cursor=" .. cursor) or ""
    )

    local success, result = pcall(function()
        return HttpService:JSONDecode(game:HttpGet(url))
    end)

    return success and result or nil
end

-- ‡∏õ‡∏∏‡πà‡∏° Server Hop
ServerTab:Button({
    Title = "Server Hop",
    Callback = function()
        task.spawn(function()
            print("üîç ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡∏Ñ‡∏ô ‚â§ " .. TargetPlayers .. "...")

            while true do
                local cursor = nil
                local found = false

                repeat
                    local data = GetServers(cursor)
                    if not data then break end

                    for _, server in ipairs(data.data) do
                        local playing = server.playing or 0
                        if playing <= TargetPlayers and playing < server.maxPlayers then
                            print("üìå ‡πÄ‡∏à‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü:", server.id, " | ‡∏Ñ‡∏ô:", playing)
                            TeleportService:TeleportToPlaceInstance(PlaceIdForHop, server.id, LocalPlayer)
                            found = true
                            break
                        end
                    end

                    cursor = data.nextPageCursor
                until cursor == nil or found

                task.wait(0.2)
            end
        end)
    end
})

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Rejoin
local function Rejoin()
    local jobId = game.JobId
    local success, err = pcall(function()
        TeleportService:TeleportToPlaceInstance(placeId, jobId, LocalPlayer)
    end)

    if not success then
        warn("Rejoin ‡πÅ‡∏ö‡∏ö instance ‡πÄ‡∏î‡∏¥‡∏°‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:", err)
        TeleportService:Teleport(placeId, LocalPlayer)
    end
end

-- ‡∏õ‡∏∏‡πà‡∏° Rejoin
ServerTab:Button({
    Title = "Rejoin",
    Callback = function()
        Rejoin()
    end
})

local SpeedEnabled = false
local speedMultiplier = 0.10
local JumpEnabled = false
local HideNameEnabled = false
local AntiLookEnabled = false
local AntiRagdollEnabled = false

local bankButton = CheaterTab:Button({
    Title = "üè¶ Bank Balance :",
    Desc = "<font color=\"rgb(0,255,255)\">$0</font>", -- ‡∏™‡∏µ‡∏ü‡πâ‡∏≤‡∏™‡∏î‡πÉ‡∏™
    Locked = false,
    Callback = function()
        -- ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î
    end
})

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏°‡∏∑‡∏≠
local handButton = CheaterTab:Button({
    Title = "üíµ Hand Balance :",
    Desc = "<font color=\"rgb(0,255,0)\">$0</font>", -- ‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏™‡∏î‡πÉ‡∏™
    Locked = false,
    Callback = function()
        -- ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î
    end
})

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô ATM
local function GetBankMoney()
    if Data_upvr.money and type(Data_upvr.money.bank) == "number" then
        return Data_upvr.money.bank
    else
        return 0
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏°‡∏∑‡∏≠
local function GetHandMoney()
    if Data_upvr.money and type(Data_upvr.money.hand) == "number" then
        return Data_upvr.money.hand
    else
        return 0
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Desc ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if bankButton and bankButton.SetDesc then
        local bankMoney = GetBankMoney()
        bankButton:SetDesc(("<font color=\"rgb(0,255,255)\">$%s</font>"):format(tostring(bankMoney)))
    end
    if handButton and handButton.SetDesc then
        local handMoney = GetHandMoney()
        handButton:SetDesc(("<font color=\"rgb(0,255,0)\">$%s</font>"):format(tostring(handMoney)))
    end
end)
CheaterTab:Divider()
CheaterTab:Section({Title="speed & jump :"})

CheaterTab:Slider({
    Title = "Speed Multiplier :",
    Value = {Min = 0.00, Max = 0.15, Default = speedMultiplier},
    Step = 0.05,
    Callback = function(value)
        speedMultiplier = value
    end
})

CheaterTab:Toggle({
    Title = "Speed",
    Flag = "SpeedEnabled",
    Value = SpeedEnabled,
    Callback = function(state)
        SpeedEnabled = state
    end
})

RunService.RenderStepped:Connect(function(delta)
    if SpeedEnabled and LocalPlayer.Character then
        local char = LocalPlayer.Character
        local hum = char:FindFirstChildOfClass("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        if hum and root then
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                root.CFrame = root.CFrame + moveDir.Unit * speedMultiplier * delta * 60
            end
        end
    end
end)

local JumpEnabled = false
local JumpValue = 20

local function ApplyJump(value)
    JumpValue = value or JumpValue
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = JumpValue
        hum.JumpHeight = JumpValue / 2
    end
end

local function RemoveJump()
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = 50
        hum.JumpHeight = 7.2
    end
end

CheaterTab:Slider({
    Title = "Jump Height",
    Step = 1,
    Value = {Min = 10, Max = 200, Default = 20}, 
    Callback = function(value)
        JumpValue = value
        if JumpEnabled then
            ApplyJump(JumpValue)
        end
    end
})

CheaterTab:Toggle({
    Title = "Jump",
    Flag = "JumpEnabled",
    Value = JumpEnabled,
    Callback = function(state)
        JumpEnabled = state
        if not state then
            RemoveJump()
        end
    end
})

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    if JumpEnabled then
        ApplyJump(JumpValue)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    if JumpEnabled then
        ApplyJump(JumpValue)
    end
end)

CheaterTab:Divider()
CheaterTab:Section({Title="invisible :"})

CheaterTab:Button({
    Title = "invisible",
    Desc = "Press the invisibility button and reset yourself to use it immediately. If it disappears, do it again.üõ°Ô∏è",
    Callback = function()
        WindUI:Notify({
            Title = "invisible ‚úÖ",
            Content = "Invisibility is now working.üõ°Ô∏èüõ°Ô∏è",
            Icon = "shield",
        })
        task.spawn(function()
            setfflag("NextGenReplicatorEnabledWrite4", "false")
            wait(5)
            setfflag("NextGenReplicatorEnabledWrite4", "true")
        end)
    end
})

CheaterTab:Section({Title="Cheater :"})

CheaterTab:Button({
    Title = "Skip Spin",
    Callback = function()
        if _G.autoCratesEnabled then
            WindUI:Notify({Title="Skip Spin", Content="Already Enabled"})
            return
        end
        _G.autoCratesEnabled = true
        WindUI:Notify({Title="Skip Spin", Content="Auto Skip Spin Enabled"})

        local Players = game:GetService("Players")
        local player = Players.LocalPlayer

        local CrateModule = require(ReplicatedStorage.Modules.Game.CrateSystem.Crate)
        local Data_upvr = require(ReplicatedStorage.Modules.Core.Data)
        local crateUIRemote = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("ShowCrateUI")

        if CrateModule.spin then
            CrateModule.spin = function(crateClass, reward, crateInstance)
                if crateClass.FinishSpin then
                    crateClass:FinishSpin(crateInstance, reward)
                else
                    crateInstance:SetAttribute("reward", reward)
                end
            end
        end

        local function AutoOpenCrate(crateInstance)
            if not crateInstance then return end

            local method = "money"
            local price = crateInstance:GetAttribute("price")
            local crateName = crateInstance.Parent.Name

            if Data_upvr.money.hand < price and Data_upvr.crate_tokens[crateName] and Data_upvr.crate_tokens[crateName] > 0 then
                method = "token"
            end

            local reward, err = Net_upvr.get("open_crate", crateInstance, method)
            if reward then
                if CrateModule.FinishSpin then
                    CrateModule.FinishSpin(crateInstance, reward)
                else
                    crateInstance:SetAttribute("reward", reward)
                end

                if crateUIRemote then
                    pcall(function()
                        crateUIRemote:InvokeServer(crateName)
                    end)
                end

                if crateInstance:FindFirstChild("Buy") and crateInstance.Buy:IsA("RemoteFunction") then
                    pcall(function()
                        crateInstance.Buy:InvokeServer()
                    end)
                end
            end
        end

        spawn(function()
            while _G.autoCratesEnabled do
                local InventoryFolder = player:WaitForChild("Inventory")
                for _, crate in ipairs(InventoryFolder:GetChildren()) do
                    if crate:GetAttribute("opened") ~= true then
                        AutoOpenCrate(crate)
                        task.wait(0.1) 
                    end
                end
                task.wait(0.3)
            end
        end)
    end
})

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local ANIM_ID = "rbxassetid://104767795538635"
local currentAnimTrack

local function PlayAntiLook()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local anim = Instance.new("Animation")
    anim.AnimationId = ANIM_ID
    currentAnimTrack = humanoid:LoadAnimation(anim)
    currentAnimTrack.Looped = true
    currentAnimTrack:Play()
end

local function StopAntiLook()
    if currentAnimTrack then
        currentAnimTrack:Stop()
        currentAnimTrack = nil
    end
end

CheaterTab:Toggle({
    Title = "Anti Lock",
    Flag = "AntiLookEnabled",
    Value = AntiLookEnabled,
    Callback = function(state)
        AntiLookEnabled = state
        if state then 
            PlayAntiLook() 
        else 
            StopAntiLook() 
        end
    end
})
  
local player = Players.LocalPlayer  
local char = player.Character or player.CharacterAdded:Wait()  
local rootPart = char:WaitForChild("HumanoidRootPart")  
  
local PickupEnabled = false  
local CounterTable  
  
local function FindCounterTable()  
    for _, Obj in ipairs(getgc(true)) do  
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then  
            return Obj  
        end  
    end  
    return nil  
end  
  
local function NetGet(...)  
    if not CounterTable or not CounterTable.func then return end  
    local args = {...}  
    CounterTable.func = (CounterTable.func or 0) + 1  
    local success, result = pcall(function()  
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")  
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))  
    end)  
    if not success then warn("[NetGet Error]", result) end  
    return result  
end  
  
local function CheckAndPickup()  
    if not PickupEnabled then return end  
    if not rootPart or not rootPart.Parent then return end  
  
    local droppedFolder = workspace:FindFirstChild("DroppedItems") or workspace:FindFirstChild("DroppedItem")  
    if not droppedFolder then return end  
  
    for _, item in ipairs(droppedFolder:GetChildren()) do  
        if item:IsA("Model") or item:IsA("BasePart") then
            local success, modelCF = pcall(function()  
                if item:IsA("Model") then
                    return (item.GetPivot and item:GetPivot() or item:GetModelCFrame())
                else
                    return item.CFrame
                end
            end)
            if not success or not modelCF then continue end
            local distance = (rootPart.Position - modelCF.Position).Magnitude
            if distance <= 15 then
                pcall(function()
                    NetGet("pickup_dropped_item", item)
                end)
            end
        end
    end
end  
  
local function UpdateChar(newChar)  
    char = newChar  
    rootPart = char:WaitForChild("HumanoidRootPart")  
end  
  
player.CharacterAdded:Connect(UpdateChar)  
if char then  
    UpdateChar(char)  
end  
  
-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï CounterTable ‡πÅ‡∏•‡∏∞ rootPart ‡∏ó‡∏∏‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ  
task.spawn(function()  
    while true do  
        if PickupEnabled then  
            CounterTable = FindCounterTable()  
            if player.Character then  
                rootPart = player.Character:FindFirstChild("HumanoidRootPart")  
            end  
        end  
        task.wait(30)  
    end  
end)  
  
-- Loop ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°  
RunService.Heartbeat:Connect(CheckAndPickup)  
  
local PickupToggle = CheaterTab:Toggle({
    Title = "Pickup Items",
    Flag = "PickupEnabled",
    Value = PickupEnabled,
    Callback = function(state)
        PickupEnabled = state
        print("üß≤ Auto Pickup Items:", state and "ON" or "OFF")
    end
})

-- Infinite Stamina Toggle
local AutoSprintEnabled = false

CheaterTab:Toggle({
    Title = "Infinite Stamina",
    Default = false,
    Callback = function(state)
        AutoSprintEnabled = state

        -- ‡πÇ‡∏´‡∏•‡∏î Sprint Module
        local SprintModule
        local ok = pcall(function()
            SprintModule = require(ReplicatedStorage.Modules.Game.Sprint)
        end)
        if not ok or not SprintModule then
            warn("‚ùå Sprint Module not found!")
            return
        end

        local consume_stamina = SprintModule.consume_stamina
        if not consume_stamina then
            warn("‚ùå consume_stamina not found in Sprint Module")
            return
        end

        -- ‡∏î‡∏∂‡∏á SprintBar
        local SprintBar
        pcall(function()
            local ups = debug.getupvalues(consume_stamina)
            SprintBar = ups[2] and ups[2].sprint_bar
        end)

        if not SprintBar or not SprintBar.update then
            warn("‚ùå SprintBar not found or missing update function")
            return
        end

        if state then
            -- ‡πÄ‡∏Å‡πá‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏î‡∏¥‡∏°
            getgenv().OriginalSprintUpdate = SprintBar.update

            -- Lock Stamina Full
            SprintBar.update = function()
                return 1
            end

            -- Auto Sprint Loop
            getgenv().AutoSprintLoop = task.spawn(function()
                while AutoSprintEnabled do
                    pcall(function()
                        if Net then
                            Net.send("set_sprinting_1", true)
                            task.wait(0.4)
                            Net.send("set_sprinting_1", false)
                        end
                    end)
                    task.wait(0.15)
                end
                -- ‡∏õ‡∏¥‡∏î Sprint
                pcall(function()
                    if Net then
                        Net.send("set_sprinting_1", false)
                    end
                end)
            end)

            WindUI:Notify({
                Title = "INF STAMINA",
                Description = "‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
                Duration = 3
            })
        else
            -- ‡∏õ‡∏¥‡∏î Auto Sprint Loop
            if getgenv().AutoSprintLoop then
                task.cancel(getgenv().AutoSprintLoop)
                getgenv().AutoSprintLoop = nil
            end

            -- Reset Sprint state
            pcall(function()
                if Net then
                    Net.send("set_sprinting_1", false)
                end
            end)

            -- Restore original update function
            if getgenv().OriginalSprintUpdate then
                pcall(function()
                    local ups = debug.getupvalues(consume_stamina)
                    local SprintBar = ups[2] and ups[2].sprint_bar
                    if SprintBar then
                        SprintBar.update = getgenv().OriginalSprintUpdate
                    end
                end)
            end
            getgenv().OriginalSprintUpdate = nil

            WindUI:Notify({
                Title = "INF STAMINA",
                Description = "‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß",
                Duration = 3
            })
        end
    end
})

-- Bypass Kick Function (‡πÉ‡∏™‡πà‡∏•‡πà‡∏≤‡∏á‡∏™‡∏∏‡∏î)
pcall(function()
    local kickF
    -- ‡∏´‡∏≤ function kick ‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
    for _, func in ipairs(getconnections(LocalPlayer.OnKick)) do
        if func.Function then
            kickF = func.Function
            break
        end
    end

    if kickF then
        hookfunction(kickF, function(p12, p13, p14, p15, ...)
            -- return call ‡∏õ‡∏Å‡∏ï‡∏¥‡πÄ‡∏û‡∏∑‡πà‡∏≠ bypass
            return p12(p13, p14, p15, ...)
        end)
        print("‚úÖ Kick function bypass applied!")
    else
        warn("‚ùå Kick function not found!")
    end
end)

CheaterTab:Divider()
CheaterTab:Section({Title="att :"})

CheaterTab:Toggle({
    Title = "Hide Name",
    Flag = "HideNameEnabled",
    Value = HideNameEnabled,
    Callback = function(state)
        HideNameEnabled = state
        if state then
            RemoveBillboardGui()
        end
    end
})
-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï BillboardGui ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏° (Realtime)
RunService.RenderStepped:Connect(function()
    if HideNameEnabled and LocalPlayer.Character then
        for _, gui in pairs(LocalPlayer.Character:GetDescendants()) do
            if gui:IsA("BillboardGui") then
                gui:Destroy()
            end
        end
    end
end)

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ï‡∏≠‡∏ô Spawn ‡πÉ‡∏´‡∏°‡πà
LocalPlayer.CharacterAdded:Connect(function(char)
    if HideNameEnabled then
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏ô Character ‡πÉ‡∏´‡∏°‡πà
        char.DescendantAdded:Connect(function(desc)
            if desc:IsA("BillboardGui") then
                desc:Destroy()
            end
        end)
        
        -- ‡∏•‡∏ö‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô Character
        RemoveBillboardGui()
    end
end)

local UndergroundEnabled = false
local UndergroundAutoEnabled = true -- toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î
local UndergroundDepth = 50       -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡∏∂‡∏Å
local SpinSpeed = 2080            -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß
local UndergroundAngle = 0        -- ‡∏°‡∏∏‡∏°‡∏´‡∏°‡∏∏‡∏ô

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏°‡∏∏‡∏î
local function StartUnderground()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    UndergroundEnabled = true
    local initialY = hrp.Position.Y - UndergroundDepth

    local conn
    conn = RunService.RenderStepped:Connect(function(delta)
        if not UndergroundEnabled or not hrp.Parent then
            if conn then conn:Disconnect() conn = nil end
            return
        end

        UndergroundAngle = (UndergroundAngle + SpinSpeed * delta) % 360
        local rad = math.rad(UndergroundAngle)

        local offsetX = math.cos(rad) * 6 -- ‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏ß‡∏á‡∏´‡∏°‡∏∏‡∏ô 6
        local offsetZ = math.sin(rad) * 6
        local newPos = Vector3.new(hrp.Position.X + offsetX, initialY, hrp.Position.Z + offsetZ)

        -- ‡∏´‡∏°‡∏∏‡∏ô‡∏´‡∏±‡∏ô‡πÑ‡∏õ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡∏•‡∏≤‡∏á‡∏ï‡∏±‡∏ß
        hrp.CFrame = CFrame.new(newPos, Vector3.new(hrp.Position.X, initialY, hrp.Position.Z))
    end)
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡∏°‡∏∏‡∏î
local function StopUnderground()
    UndergroundEnabled = false
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à Anti Ragdoll (‡πÑ‡∏°‡πà‡∏•‡πâ‡∏°)
local function AntiRagdoll()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end
    if humanoid.PlatformStand then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        hrp.Velocity = Vector3.new(0,0,0)
        hrp.RotVelocity = Vector3.new(0,0,0)
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end

    -- Underground Auto
    if UndergroundAutoEnabled then
        if humanoid.Health < 16 and humanoid.Health > 0 then
            if not UndergroundEnabled then StartUnderground() end
        elseif humanoid.Health >= 30 or humanoid.Health <= 0 then
            if UndergroundEnabled then StopUnderground() end
        end
    end

    -- Anti Ragdoll
    AntiRagdoll()
end)

CheaterTab:Toggle({
    Title = "Anti Kill",
    Flag = "UndergroundAutoEnabled",
    Value = UndergroundAutoEnabled,
    Callback = function(state)
        UndergroundAutoEnabled = state
        if not state then UndergroundEnabled = false end
    end
})

Players.LocalPlayer.CharacterAdded:Connect(function(char)
    if UndergroundAutoEnabled then
        UndergroundEnabled = false
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local CounterTable

-- ‡∏´‡∏≤ CounterTable
local function findCounter()
    for _, obj in ipairs(getgc(true)) do
        if typeof(obj) == "table" and rawget(obj, "event") and rawget(obj, "func") then
            return obj
        end
    end
    return nil
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏° Anti Ragdoll
local function startAntiRagdoll()
    CounterTable = findCounter()
    if not CounterTable then
        warn("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö CounterTable!")
        return
    end

    spawn(function()
        while AntiRagdollEnabled do
            CounterTable.event = (CounterTable.event or 0) + 1
            local SendRemote = ReplicatedStorage.Remotes:WaitForChild("Send")
            pcall(function()
                SendRemote:FireServer(CounterTable.event, "end_ragdoll_early")
            end)
            wait(0.3)

            if AntiRagdollEnabled then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "clear_ragdoll")
                end)
            end
            wait(0.3)
        end
    end)
end

CheaterTab:Toggle({
    Title = "Anti Ragdoll",
    Flag = "AntiRagdollEnabled",
    Value = AntiRagdollEnabled,
    Callback = function(state)
        AntiRagdollEnabled = state
        if state then
            startAntiRagdoll()
            print("‚úÖ Anti Ragdoll ON")
        else
            print("‚ùå Anti Ragdoll OFF")
        end
    end
})
-- Auto start ‡πÄ‡∏°‡∏∑‡πà‡∏≠ respawn
player.CharacterAdded:Connect(function()
    if AntiRagdollEnabled then
        wait(1)
        startAntiRagdoll()
    end
end)

CheaterTab:Divider()
CheaterTab:Section({Title="Snap PC key [ Z ]"})

local JumpEnabled = false
local SnapHeightOffset = -7
local SnapDirection = "Down"
local SnapDuration = 0.1
local SnapBlockDuration = 5

local isRunning = false

local function SnapQuick()
    if isRunning then return end
    isRunning = true

    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then isRunning=false return end

    local blocks = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            local blk = Instance.new("Part")
            blk.Size = part.Size
            blk.CFrame = part.CFrame
            blk.Anchored = true
            blk.CanCollide = false
            blk.Material = Enum.Material.Neon
            blk.Transparency = 0.5
            blk.Color = Color3.fromRGB(0,170,255) -- ‡∏™‡∏µ‡∏ü‡πâ‡∏≤
            blk.Parent = workspace
            table.insert(blocks, blk)
        end
    end

    -- ‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏´‡πâ‡∏•‡∏ö‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    task.spawn(function()
        task.wait(SnapBlockDuration)
        for _, blk in ipairs(blocks) do
            if blk and blk.Parent then blk:Destroy() end
        end
    end)

    hum.Sit = true
    local origY = hrp.Position.Y
    local offset = math.abs(SnapHeightOffset)
    if SnapDirection == "Down" then offset = -offset end

    local conn
    conn = RunService.RenderStepped:Connect(function()
        if hrp and hrp.Parent then
            hrp.CFrame = hrp.CFrame:Lerp(CFrame.new(hrp.Position.X, origY+offset, hrp.Position.Z),0.8)

            for i, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") and blocks[i] then
                    local blk = blocks[i]
                    if blk and blk.Parent then
                        blk.CFrame = part.CFrame
                    end
                end
            end
        end
    end)

    task.wait(SnapDuration)
    if conn then conn:Disconnect() conn=nil end
    hum.Sit = false
    isRunning=false
end

CheaterTab:Button({
    Title="Snap Click",
    Locked=false,
    Callback=function() SnapQuick() end
})

CheaterTab:Slider({
    Title = "Snap Depth",
    Flag = "SnapHeightOffset",
    Step = 1,
    Value = {Min = 1, Max = 50, Default = math.abs(SnapHeightOffset)},
    Callback = function(val)
        SnapHeightOffset = (SnapDirection=="Down" and -1 or 1)*val
    end
})

-- Dropdown Snap Direction
CheaterTab:Dropdown({
    Title="Snap Direction",
    Values={"Down","Up"},
    Value=SnapDirection,
    Callback=function(opt)
        SnapDirection=opt
        SnapHeightOffset=(opt=="Down" and -1 or 1)*math.abs(SnapHeightOffset)
    end
})

UserInputService.InputBegan:Connect(function(input,gpe)
    if gpe then return end
    if input.KeyCode==Enum.KeyCode.Z then SnapQuick() end
end)


local ConfigManager = Window.ConfigManager  
local Loaded = false  
local AutoSaveName = "MyAutoConfig"  
_G.LastConfigName = _G.LastConfigName or AutoSaveName  

local function SendNotify(title, content, icon)  
    if WindUI and WindUI.Notify then  
        pcall(function()
            WindUI:Notify({  
                Title = title or "Notification",  
                Content = content or "",  
                Duration = 2,  
                Icon = icon or "zap"  
            })  
        end)
    end  
end  

-- ‡∏õ‡∏∏‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Config
SettingsTab:Button({  
    Title = "Save Config",  
    Icon = "save",  
    Callback = function()  
        local oldCfg = ConfigManager:CreateConfig(AutoSaveName)  
        oldCfg:Delete()  -- ‡∏•‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÉ‡∏´‡∏°‡πà  
        local c = ConfigManager:CreateConfig(AutoSaveName)  
        c:Save()  
        _G.LastConfigName = AutoSaveName  
        SendNotify("Config Manager", "Config Successfully Saved", "save")  
    end  
})  

-- ‡∏õ‡∏∏‡πà‡∏°‡πÇ‡∏´‡∏•‡∏î Config
SettingsTab:Button({  
    Title = "Load Config",  
    Icon = "clock",  
    Callback = function()  
        local success, err = pcall(function()  
            local cfg = ConfigManager:CreateConfig(AutoSaveName)  
            cfg:Load()  
        end)  
        if success then  
            _G.LastConfigName = AutoSaveName  
            SendNotify("Config Manager", "Config Successfully Loaded", "check")  
        else  
            SendNotify("Config Manager", "Load Failed: " .. tostring(err), "alert")  
        end  
    end  
})  

-- ‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏ö Config
SettingsTab:Button({  
    Title = "Delete Config",  
    Icon = "trash",  
    Callback = function()  
        local success, err = pcall(function()  
            local cfg = ConfigManager:CreateConfig(AutoSaveName)  
            cfg:Delete()  
        end)  
        if success then  
            SendNotify("Config Manager", "Config Successfully Deleted", "trash")  
        else  
            SendNotify("Config Manager", "Delete Failed: " .. tostring(err), "alert")  
        end  
    end  
})  

-- ‡πÇ‡∏´‡∏•‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°
task.spawn(function()  
    while not ConfigManager or not WindUI or not WindUI.Notify do  
        task.wait(0.5)  
    end  

    if Loaded then return end  
    Loaded = true  

    SendNotify("Config Manager", "Loading Config...", "clock")  
    task.wait(1)  

    local success, err = pcall(function()  
        local cfg = ConfigManager:CreateConfig(AutoSaveName)  
        cfg:Load()  
    end)  

    if success then  
        _G.LastConfigName = AutoSaveName  
        SendNotify("Config Manager", "Config Successfully Loaded", "check")  
    else  
        SendNotify("Config Manager", "Load Failed: " .. tostring(err), "alert")  
    end  
end)
