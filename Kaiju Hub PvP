local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

local Window = WindUI:CreateWindow({
    Title = "‚òÉÔ∏è Kaiju Hub | Pvp",
    Icon = "layout-list", 
    Author = "‚ùÑÔ∏è My Kaiju |  BlockSpin | I love You :D !",
    Folder = "MyKaijuHub",
    Size = UDim2.fromOffset(400, 350),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 200,
    HideSearchBar = false,
    ScrollBarEnabled = true,
})

Window:Tag({
    Title = "One for all ",
    Icon = "star",
    Color = Color3.fromHex("#F7D30A"),
    Radius = 13,
})

Window:Tag({
    Title = "v 1.2 GOD !",
    Color = Color3.fromHex("#FF2B00"),
    Radius = 13,
})

Window:EditOpenButton({ Enabled = false })

local ScreenGui = Instance.new("ScreenGui")
local ToggleBtn = Instance.new("ImageButton")

ScreenGui.Name = "WindUI_Toggle"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

ToggleBtn.Size = UDim2.new(0, 50, 0, 50)
ToggleBtn.Position = UDim2.new(0, 20, 0.5, -25)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Image = "rbxassetid://125837038699764" -- ‡πÄ‡∏ô¬É‡πÄ‡∏ò‡∏ä‡πÄ‡∏ô¬à‡πÄ‡∏ô‚Ç¨‡πÄ‡∏ò‡∏Ö‡πÄ‡∏ò¬Ç ImageId ‡πÄ‡∏ò‚Ä¢‡πÄ‡∏ò‡∏ë‡πÄ‡∏ò‡∏á‡πÄ‡∏ô‚Ç¨‡πÄ‡∏ò‡∏ç‡πÄ‡∏ò¬á
ToggleBtn.Active = true
ToggleBtn.Draggable = true
ToggleBtn.Parent = ScreenGui

local opened = true

local function toggle()
    opened = not opened
    if Window.UI then
        Window.UI.Enabled = opened
    else
        Window:Toggle()
    end
end

ToggleBtn.MouseButton1Click:Connect(function()
    ToggleBtn:TweenSize(
        UDim2.new(0, 56, 0, 56),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Quad,
        0.12,
        true,
        function()
            ToggleBtn:TweenSize(
                UDim2.new(0, 50, 0, 50),
                Enum.EasingDirection.Out,
                Enum.EasingStyle.Quad,
                0.12,
                true
            )
        end
    )
    toggle()
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.G then
        toggle()
    end
end)

local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})

local WeaponTab = Window:Tab({Title = "Weapon Mods:", Icon = "crosshair"})
WeaponTab:Section({Title="Weapon Mods :"})

local CheaterTab = Window:Tab({Title = "CHEATER:", Icon = "user"})
CheaterTab:Section({Title="CHEATER :"})

local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})

local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="üåê state :"})

local SettingsTab = Window:Tab({Title = "Settings", Icon = "settings"})
SettingsTab:Section({Title="Settings  :"})

local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Value = false
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 150
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Value = 1000
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"
TargetPartValue.Parent = LocalPlayer

local AttackAntiLockEnabledValue = Instance.new("BoolValue")
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false
AttackAntiLockEnabledValue.Parent = LocalPlayer

local AttackAntiKillEnabledValue = Instance.new("BoolValue")
AttackAntiKillEnabledValue.Name = "AttackAntiKillEnabled"
AttackAntiKillEnabledValue.Value = false
AttackAntiKillEnabledValue.Parent = LocalPlayer

local IgnorePlayers = {}
local CurrentTarget, head, aimPos
local hue = 0

-- ‡∏õ‡∏∑‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
local GunNames = {"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9","Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- Tracer
local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 1
tracerLine.Visible = false

local PREDICTION_FACTOR = 0.165

local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end

    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)

    -- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏£‡∏ñ (‡πÄ‡∏û‡∏¥‡πà‡∏° Velocity ‡∏£‡∏ñ x1.2)
    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end

    return prediction
end

-- AntiLockPrediction + Attack Anti Kill
local function AntiLockPrediction(part)
    if not part or not part.Parent then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    local humanoid = part.Parent:FindFirstChild("Humanoid")
    if not humanoid then return part.Position end

    local headPos = part.Position + Vector3.new(0, (part:IsA("BasePart") and part.Size.Y or 1)/2, 0)

    -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡∏¥‡∏î Attack Anti Kill ‡∏Ñ‡∏∑‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡∏£‡∏á ‡πÜ
    if AttackAntiKillEnabledValue.Value then
        return headPos
    end

    if AttackAntiLockEnabledValue.Value then
        local speed = root and root.Velocity.Magnitude or 0
        local factor = (speed >= 14) and 6 or 0
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÅ‡∏ö‡∏ö‡∏™‡∏µ‡πà‡∏°‡∏∏‡∏° (x,z)
        local vel = root.Velocity
        local x = vel.X
        local z = vel.Z
        local dir = Vector3.new(0,0,0)
        if math.abs(x) > math.abs(z) then
            dir = Vector3.new((x>0 and 1 or -1)*factor,0,0)
        else
            dir = Vector3.new(0,0,(z>0 and 1 or -1)*factor)
        end
        return headPos + dir
    else
        return PredictPosition(part)
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Ignore
local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

-- ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏Å‡∏•‡πâ FOV
local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ñ‡∏∑‡∏≠‡∏õ‡∏∑‡∏ô
local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

-- ‡∏ï‡∏£‡∏ß‡∏à‡∏Å‡∏≥‡πÅ‡∏û‡∏á
local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

-- Hook ‡∏¢‡∏¥‡∏á
-- Hook ‡∏¢‡∏¥‡∏á
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = AntiLockPrediction(part)

            if MagicBulletValue.Value and (part and part.Parent and IsBehindWall(part)) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.05,0.05,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.new(1,1,1) -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
            game:GetService("Debris"):AddItem(beam, 1)

            -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á‡∏´‡∏•‡∏±‡∏á 0.4 ‡∏ß‡∏¥
            task.delay(0.4, function()
                if beam and beam.Parent then
                    local hue = math.random()
                    beam.Color = Color3.fromHSV(hue, 1, 1)
                end
            end)
        end
    end
    return oldFire(self, unpack(args))
end)
-- Render FOV + Tracer
RunService.RenderStepped:Connect(function()
    -- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï FOV
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1) -- FOV ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏£‡∏∏‡πâ‡∏á

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    CurrentTarget = target

    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromRGB(255,80,80) -- Tracer ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏≠‡πà‡∏≠‡∏ô‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

CombatTab:Toggle({
    Title = "Silent Aim",
    Flag = "SilentAimEnabled",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Flag = "AttackAntiLockEnabled",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Kill",
    Flag = "AttackAntiKillEnabled",
    Value = AttackAntiKillEnabledValue.Value,
    Callback = function(state)
        AttackAntiKillEnabledValue.Value = state
    end
})

CombatTab:Space()

CombatTab:Slider({
    Title = "FOV :",
    Flag = "FOVRadius",
    Value = {Min = 10, Max = 1000, Default = 150},
    Step = 5,
    Callback = function(value)
        FOVRadiusValue.Value = value
        fovCircle.Radius = value
    end
})

CombatTab:Slider({
    Title = "Lock Distance :",
    Flag = "LockDistance",
    Value = {Min = 50, Max = 3000, Default = 1000},
    Step = 25,
    Callback = function(value)
        LockDistanceValue.Value = value
    end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

CombatTab:Toggle({
    Title = "Magic Bullet",
    Flag = "MagicBullet",
    Value = MagicBulletValue.Value,
    Callback = function(state)
        MagicBulletValue.Value = state
    end
})

local function UpdatePlayerNames()
    local names = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            table.insert(names, plr.Name)
        end
    end
    return names
end

CombatTab:Space()

CombatTab:Dropdown({
    Title = "üõ°Ô∏èSafe Players",
    Multi = true,
    AllowNone = true,
    Values = UpdatePlayerNames(),
    Value = {},
    Callback = function(selected)
        IgnorePlayers = {}
        for _, name in ipairs(selected) do
            table.insert(IgnorePlayers, name)
        end
        print("Safe Players Updated: " .. table.concat(IgnorePlayers, ", "))
    end
})

CombatTab:Button({
    Title = "üîÅSafe player List",
    Callback = function()
        local newValues = UpdatePlayerNames()
        safePlayersDropdown:SetValues(newValues)
        print("‚úÖ Player list refreshed")
    end
})

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- FireRate
local Automatic = false
local FireRate = 1500
local toolCache = {}

local function matchesTarget(name, target)
    name = name:lower()
    target = target:lower()
    return name:find(target) ~= nil or name:match("%d*_" .. target .. "_?%d*") ~= nil
end

local function applyAttributesSmart(gun)
    if not gun then return end
    local prev = toolCache[gun]
    if prev and prev.FireRate == FireRate then return end

    if gun:GetAttribute("fire_rate") ~= nil then
        gun:SetAttribute("fire_rate", FireRate)
    end

    for _, child in ipairs(gun:GetDescendants()) do
        if (child:IsA("NumberValue") or child:IsA("IntValue")) and matchesTarget(child.Name, "fire_rate") then
            child.Value = FireRate
        end
    end

    toolCache[gun] = { FireRate = FireRate }
end

local function updateAllGuns()
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                applyAttributesSmart(tool)
            end
        end
    end

    if player:FindFirstChild("Backpack") then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                applyAttributesSmart(tool)
            end
        end
    end
end

player.CharacterAdded:Connect(function(char)
    if Automatic then updateAllGuns() end
    char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and Automatic then
            applyAttributesSmart(child)
        end
    end)
end)

player.Backpack.ChildAdded:Connect(function(child)
    if child:IsA("Tool") and Automatic then
        applyAttributesSmart(child)
    end
end)

-- FireRate Toggle
WeaponTab:Toggle({
    Title = "Automatic",
    Value = Automatic,
    Flag = "AutomaticGuns",
    Callback = function(state)
        Automatic = state
        if Automatic then updateAllGuns() end
    end
})

WeaponTab:Slider({
    Title = "Fire Rate",
    Value = { Min = 100, Max = 2000, Default = FireRate },
    Step = 1,
    Flag = "FireRate",
    Callback = function(value)
        FireRate = tonumber(value)
        updateAllGuns()
    end
})

-- No Recoil
local GunModule = require(ReplicatedStorage.Modules.Game.ItemTypes.Gun)
getgenv().NoRecoilEnabled = false
local original_recoil = GunModule.apply_recoil
local antiLoop = nil

local function EnableNoRecoil()
    if getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = true

    GunModule.apply_recoil = function(arg1)
        if arg1 and arg1.instance then
            arg1.instance:SetAttribute("Recoil", 0)
        end
    end

    antiLoop = task.spawn(function()
        while getgenv().NoRecoilEnabled do
            local char = Players.LocalPlayer.Character
            local tool = char and char:FindFirstChildOfClass("Tool")
            if tool and tool:GetAttribute("Recoil") then
                tool:SetAttribute("Recoil", 0)
            end
            task.wait(0.3)
        end
    end)

    print("‚úÖ No Recoil: ON")
end

local function DisableNoRecoil()
    if not getgenv().NoRecoilEnabled then return end
    getgenv().NoRecoilEnabled = false
    GunModule.apply_recoil = original_recoil
    if antiLoop then task.cancel(antiLoop); antiLoop=nil end
    print("‚ùå No Recoil: OFF")
end

WeaponTab:Toggle({
    Title = "No Recoil",
    Value = getgenv().NoRecoilEnabled,
    Flag = "NoRecoil",
    Callback = function(state)
        if state then EnableNoRecoil() else DisableNoRecoil() end
    end
})

-- Hit Aura
getgenv().HitAuraEnabled = false
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

local SendRemote
pcall(function()
    local Remotes = ReplicatedStorage:WaitForChild("Remotes", 10)
    SendRemote = Remotes:WaitForChild("Send", 5)
end)

local function NetSend(...)
    if not CounterTable or not CounterTable.event or not SendRemote then return end
    local args = {...}
    CounterTable.event = (CounterTable.event or 0) + 1
    pcall(function()
        SendRemote:FireServer(CounterTable.event, unpack(args))
    end)
end

local function getActiveTool()
    local char = player.Character
    if not char then return nil end
    for _, obj in pairs(char:GetChildren()) do
        if obj:IsA("Tool") then return obj end
    end
    return nil
end

local function getPlayersInRange(radius)
    local inRange = {}
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return inRange end
    local pos = char.HumanoidRootPart.Position
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart")
           and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0 then
            local dist = (p.Character.HumanoidRootPart.Position - pos).Magnitude
            if dist <= radius then table.insert(inRange, p) end
        end
    end
    return inRange
end

local autoLoop
local function AttackNearby()
    local tool = getActiveTool()
    if not tool then return end
    local targets = getPlayersInRange(12)
    for _, target in ipairs(targets) do
        local hrp = player.Character.HumanoidRootPart
        local targetHRP = target.Character.HumanoidRootPart
        if hrp and targetHRP then
            local lookAtCFrame = CFrame.lookAt(hrp.Position, targetHRP.Position)
            NetSend("melee_attack", tool, {target}, lookAtCFrame, 0.75)
        end
    end
end

local function StartHitAura()
    if autoLoop then return end
    autoLoop = task.spawn(function()
        while getgenv().HitAuraEnabled do
            pcall(AttackNearby)
            task.wait(0.3)
        end
    end)
end

local function StopHitAura()
    getgenv().HitAuraEnabled = false
    if autoLoop then task.cancel(autoLoop); autoLoop=nil end
end

WeaponTab:Toggle({
    Title = "Hit Aura",
    Value = getgenv().HitAuraEnabled,
    Flag = "HitAura",
    Callback = function(state)
        if state then
            getgenv().HitAuraEnabled = true
            StartHitAura()
            print("‚úÖ Hit Aura: ON")
        else
            StopHitAura()
            print("‚ùå Hit Aura: OFF")
        end
    end
})
