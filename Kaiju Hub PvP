local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Players, RunService, Camera, LocalPlayer, ReplicatedStorage =
    game:GetService("Players"),
    game:GetService("RunService"),
    workspace.CurrentCamera,
    game.Players.LocalPlayer,
    game:GetService("ReplicatedStorage")

local Window = WindUI:CreateWindow({
    Title = "Kaiju Hub | Pvp",
    Icon = "gitlab",
    Author = "My Kaiju | BlockSpin | i love You :D !",
    Folder = "XINCOHubFolder",
    Size = UDim2.fromOffset(400, 350),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

Window:Tag({
    Title = "PAID",
    Icon = "lock-keyhole",
    Color = Color3.fromHex("#90C6FC"),
    Radius = 13,
})

Window:Tag({
    Title = "v0.5.8",
    Color = Color3.fromHex("#2889F7"),
    Radius = 13,
})

Window:EditOpenButton({
    Title = "Kaiju Hub",
    Icon = "circle-ellipsis",
    CornerRadius = UDim.new(0,50),
    StrokeThickness = 3,
    Color = ColorSequence.new(
        Color3.fromHex("292DFF"), 
        Color3.fromHex("6E6BFF")
    ),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

local CombatTab = Window:Tab({Title = "COMBAT:", Icon = "crosshair"})
CombatTab:Section({Title="GUN :"})
local CheaterTab = Window:Tab({Title = "CHEATER:", Icon = "user"})
CheaterTab:Section({Title="CHEATER :"})
local MiscTab = Window:Tab({Title = "MISC:", Icon = "warehouse"})
MiscTab:Section({Title="Misc :"})
local EspTab = Window:Tab({Title = "Esp", Icon = "user"})
EspTab:Section({Title="Esp PLAYER  :"})
local WeaponTab = Window:Tab({Title = "Weapon Mods:", Icon = "crosshair"})
WeaponTab:Section({Title="Weapon Mods :"})
local ServerTab = Window:Tab({Title = "Server", Icon = "server"})
ServerTab:Section({Title="Server Hop  :"})
local SettingsTab = Window:Tab({Title = "Settings", Icon = "settings"})
SettingsTab:Section({Title="Settings  :"})

local SilentAimEnabledValue = Instance.new("BoolValue")
SilentAimEnabledValue.Name = "SilentAimEnabled"
SilentAimEnabledValue.Value = false
SilentAimEnabledValue.Parent = LocalPlayer

local MagicBulletValue = Instance.new("BoolValue")
MagicBulletValue.Name = "MagicBullet"
MagicBulletValue.Value = false
MagicBulletValue.Parent = LocalPlayer

local FOVRadiusValue = Instance.new("NumberValue")
FOVRadiusValue.Name = "FOVRadius"
FOVRadiusValue.Value = 150
FOVRadiusValue.Parent = LocalPlayer

local LockDistanceValue = Instance.new("NumberValue")
LockDistanceValue.Name = "LockDistance"
LockDistanceValue.Value = 1000
LockDistanceValue.Parent = LocalPlayer

local TargetPartValue = Instance.new("StringValue")
TargetPartValue.Name = "TargetPart"
TargetPartValue.Value = "Head"
TargetPartValue.Parent = LocalPlayer

local AttackAntiLockEnabledValue = Instance.new("BoolValue")
AttackAntiLockEnabledValue.Name = "AttackAntiLockEnabled"
AttackAntiLockEnabledValue.Value = false
AttackAntiLockEnabledValue.Parent = LocalPlayer

local AttackAntiKillEnabledValue = Instance.new("BoolValue")
AttackAntiKillEnabledValue.Name = "AttackAntiKillEnabled"
AttackAntiKillEnabledValue.Value = false
AttackAntiKillEnabledValue.Parent = LocalPlayer

local IgnorePlayers = {}
local CurrentTarget, head, aimPos
local hue = 0

local GunNames = {"P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9","Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"}
local GunLookup = {}
for _, name in pairs(GunNames) do GunLookup[name] = true end

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 100
fovCircle.Radius = FOVRadiusValue.Value
fovCircle.Filled = false
fovCircle.Visible = SilentAimEnabledValue.Value
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

local tracerLine = Drawing.new("Line")
tracerLine.Thickness = 1
tracerLine.Visible = false

local PREDICTION_FACTOR = 0.165

local function PredictPosition(headPart)
    local root = headPart.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return headPart.Position end

    local velocity = root.Velocity
    local prediction = headPart.Position + (velocity * PREDICTION_FACTOR)

    local seat = root:FindFirstChildWhichIsA("WeldConstraint") or root:FindFirstChildWhichIsA("Weld")
    if seat and seat.Part0 then
        prediction = headPart.Position + (seat.Part0.Velocity * PREDICTION_FACTOR * 1.2)
    end

    return prediction
end

-- AntiLockPrediction + Attack Anti Kill
local function AntiLockPrediction(part)
    if not part or not part.Parent then return part.Position end
    local root = part.Parent:FindFirstChild("HumanoidRootPart")
    local humanoid = part.Parent:FindFirstChild("Humanoid")
    if not humanoid then return part.Position end

    local headPos = part.Position + Vector3.new(0, (part:IsA("BasePart") and part.Size.Y or 1)/2, 0)

    if AttackAntiKillEnabledValue.Value then
        return headPos
    end

    if AttackAntiLockEnabledValue.Value then
        local speed = root and root.Velocity.Magnitude or 0
        local factor = (speed >= 14) and 6 or 0
        local vel = root.Velocity
        local x = vel.X
        local z = vel.Z
        local dir = Vector3.new(0,0,0)
        if math.abs(x) > math.abs(z) then
            dir = Vector3.new((x>0 and 1 or -1)*factor,0,0)
        else
            dir = Vector3.new(0,0,(z>0 and 1 or -1)*factor)
        end
        return headPos + dir
    else
        return PredictPosition(part)
    end
end

local function IsIgnored(plr)
    for _, name in ipairs(IgnorePlayers) do
        if string.lower(plr.Name) == string.lower(name) then
            return true
        end
    end
    return false
end

local function GetClosestTarget()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not IsIgnored(player) and player.Character and player.Character:FindFirstChild("Head") then
            local headPart = player.Character:FindFirstChild(TargetPartValue.Value) or player.Character:FindFirstChild("Head")
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then continue end
            local distance = (headPart.Position - LocalPlayer.Character.Head.Position).Magnitude
            if distance > LockDistanceValue.Value then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(headPart.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist < FOVRadiusValue.Value and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if ok and typeof(weapon) == "Instance" and GunLookup[weapon.Name] then return true end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local function IsBehindWall(targetHead)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Head") then return false end
    local origin = LocalPlayer.Character.Head.Position
    local direction = targetHead.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetHead.Parent}
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance and not result.Instance:IsDescendantOf(targetHead.Parent)
end

local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabledValue.Value and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTarget()
        if CurrentTarget then
            local part = CurrentTarget.Character:FindFirstChild(TargetPartValue.Value) or CurrentTarget.Character:FindFirstChild("Head")
            head = part
            aimPos = AntiLockPrediction(part)

            if MagicBulletValue.Value and (part and part.Parent and IsBehindWall(part)) then
                args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            else
                args[4] = CFrame.new(LocalPlayer.Character.Head.Position, aimPos)
            end

            args[5] = {[1] = {[1] = {["Instance"] = head, ["Position"] = aimPos}}}

            -- Beam
            local ourHead = LocalPlayer.Character.Head
            local distance = (aimPos - ourHead.Position).Magnitude
            local beam = Instance.new("Part", workspace)
            beam.Anchored = true
            beam.CanCollide = false
            beam.Material = Enum.Material.Neon
            beam.Size = Vector3.new(0.15,0.15,distance)
            beam.CFrame = CFrame.new(ourHead.Position, aimPos) * CFrame.new(0,0,-distance/2)
            beam.Color = Color3.fromHSV(math.random(),1,1)
            game:GetService("Debris"):AddItem(beam, 1)
        end
    end
    return oldFire(self, unpack(args))
end)

RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    fovCircle.Radius = FOVRadiusValue.Value
    hue = (hue + 0.0005) % 1
    fovCircle.Color = Color3.fromHSV(hue, 1, 1)

    if not SilentAimEnabledValue.Value then
        tracerLine.Visible = false
        return
    end

    local target = GetClosestTarget()
    CurrentTarget = target

    if target and target.Character and target.Character:FindFirstChild("Head") then
        local headPos = target.Character:FindFirstChild(TargetPartValue.Value).Position or target.Character.Head.Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
        if onScreen then
            local centerScreen = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
            tracerLine.From = centerScreen
            tracerLine.To = Vector2.new(screenPos.X, screenPos.Y)
            tracerLine.Color = Color3.fromHSV(hue, 1, 1)
            tracerLine.Visible = true
        else
            tracerLine.Visible = false
        end
    else
        tracerLine.Visible = false
    end
end)

CombatTab:Toggle({
    Title = "Silent Aim",
    Value = SilentAimEnabledValue.Value,
    Callback = function(state)
        SilentAimEnabledValue.Value = state
        fovCircle.Visible = state
        tracerLine.Visible = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Lock",
    Value = AttackAntiLockEnabledValue.Value,
    Callback = function(state)
        AttackAntiLockEnabledValue.Value = state
    end
})

CombatTab:Toggle({
    Title = "Attack Anti Kill",
    Value = AttackAntiKillEnabledValue.Value,
    Callback = function(state)
        AttackAntiKillEnabledValue.Value = state
        if state then
            print("âœ… Attack Anti Kill: ON (Prediction Disabled)")
        else
            print("âŒ Attack Anti Kill: OFF (Prediction Enabled)")
        end
    end
})

CombatTab:Space()

CombatTab:Slider({
    Title = "FOV :",
    Step = 5,
    Value = {Min = 10, Max = 1000, Default = FOVRadiusValue.Value},
    Callback = function(value) FOVRadiusValue.Value = value end
})

CombatTab:Slider({
    Title = "Lock Distance :",
    Step = 25,
    Value = {Min = 50, Max = 3000, Default = LockDistanceValue.Value},
    Callback = function(value) LockDistanceValue.Value = value end
})

CombatTab:Dropdown({
    Title = "Target Part",
    Values = {"Head","HumanoidRootPart"},
    Value = TargetPartValue.Value,
    Callback = function(option) TargetPartValue.Value = option end
})

CombatTab:Toggle({
    Title = "Magic Bullet",
    Value = MagicBulletValue.Value,
    Callback = function(state) MagicBulletValue.Value = state end
})

-- Safe Players Multi Dropdown + Refresh
local function UpdatePlayerNames()
    local names = {}
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            table.insert(names, plr.Name)
        end
    end
    return names
end

CombatTab:Space()

local safePlayersDropdown = CombatTab:Dropdown({
    Title = "ðŸ›¡ï¸Safe Players",
    Multi = true,
    AllowNone = true,
    Values = UpdatePlayerNames(),
    Value = {},
    Callback = function(selected)
        IgnorePlayers = {}
        for _, name in ipairs(selected) do
            table.insert(IgnorePlayers, name)
        end
        print("Safe Players Updated: " .. table.concat(IgnorePlayers, ", "))
    end
})

CombatTab:Button({
    Title = "ðŸ”Safeayer List",
    Callback = function()
        local newValues = UpdatePlayerNames()
        safePlayersDropdown:SetValues(newValues)
        print("âœ… Player list refreshed")
    end
})


local SpeedEnabled = false
local speedMultiplier = 0.10
local JumpEnabled = false
local HideNameEnabled = false
local AntiLookEnabled = false
local AntiRagdollEnabled = false

CheaterTab:Slider({
    Title = "Speed Multiplier :",
    Value = {Min = 0.00, Max = 0.15, Default = speedMultiplier},
    Step = 0.05,
    Callback = function(value)
        speedMultiplier = value
    end
})

CheaterTab:Toggle({
    Title = "Speed",
    Value = SpeedEnabled,
    Callback = function(state)
        SpeedEnabled = state
    end
})

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸›à¸£à¸±à¸š Jump
local function ApplyJump(value)
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = value or 20
        hum.JumpHeight = (value or 20)/2
    end
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸£à¸µà¹€à¸‹à¹‡à¸• Jump
local function RemoveJump()
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.JumpPower = 50
        hum.JumpHeight = 7.2
    end
end

CheaterTab:Slider({
    Title = "Jump Height",
    Step = 1,
    Value = {Min = 10, Max = 200, Default = 20}, 
    Callback = function(value)
        if JumpEnabled then
            ApplyJump(value)
        end
    end
})

-- Toggle Jump
CheaterTab:Toggle({
    Title = "Jump",
    Value = JumpEnabled,
    Callback = function(state)
        JumpEnabled = state
        if state then ApplyJump() else RemoveJump() end
    end
})

-- à¸£à¸±à¸à¸©à¸² JumpEnabled à¸•à¸­à¸™ Spawn à¹ƒà¸«à¸¡à¹ˆ
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    if JumpEnabled then
        ApplyJump()
    end
end)

CheaterTab:Space()

local function RemoveBillboardGui()
    local char = LocalPlayer.Character
    if char then
        for _, gui in pairs(char:GetDescendants()) do
            if gui:IsA("BillboardGui") then
                gui:Destroy()
            end
        end
    end
end

-- Toggle Hide Name
CheaterTab:Toggle({
    Title = "Hide Name",
    Value = HideNameEnabled,
    Callback = function(state)
        HideNameEnabled = state
        if state then
            RemoveBillboardGui()
        end
    end
})

-- à¸­à¸±à¸›à¹€à¸”à¸• BillboardGui à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡ (Realtime)
RunService.RenderStepped:Connect(function()
    if HideNameEnabled and LocalPlayer.Character then
        for _, gui in pairs(LocalPlayer.Character:GetDescendants()) do
            if gui:IsA("BillboardGui") then
                gui:Destroy()
            end
        end
    end
end)

-- à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸•à¸­à¸™ Spawn à¹ƒà¸«à¸¡à¹ˆ
LocalPlayer.CharacterAdded:Connect(function(char)
    if HideNameEnabled then
        -- à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸—à¸¸à¸à¸•à¸±à¸§à¸¥à¸¹à¸à¸—à¸µà¹ˆà¸–à¸¹à¸à¸ªà¸£à¹‰à¸²à¸‡à¹ƒà¸™ Character à¹ƒà¸«à¸¡à¹ˆ
        char.DescendantAdded:Connect(function(desc)
            if desc:IsA("BillboardGui") then
                desc:Destroy()
            end
        end)
        
        -- à¸¥à¸šà¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§à¹ƒà¸™ Character
        RemoveBillboardGui()
    end
end)

local ANIM_ID = "rbxassetid://104767795538635"
local currentAnimTrack

local function PlayAntiLook()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local anim = Instance.new("Animation")
    anim.AnimationId = ANIM_ID
    currentAnimTrack = humanoid:LoadAnimation(anim)
    currentAnimTrack.Looped = true
    currentAnimTrack:Play()
end

local function StopAntiLook()
    if currentAnimTrack then
        currentAnimTrack:Stop()
        currentAnimTrack = nil
    end
end

CheaterTab:Toggle({
    Title = "Anti Lock",
    Value = AntiLookEnabled,
    Callback = function(state)
        AntiLookEnabled = state
        if state then PlayAntiLook() else StopAntiLook() end
    end
})

-- à¸•à¸±à¸§à¹à¸›à¸£
local UndergroundEnabled = false
local UndergroundAutoEnabled = true -- toggle à¹€à¸›à¸´à¸”/à¸›à¸´à¸”
local UndergroundDepth = 50       -- à¸„à¸§à¸²à¸¡à¸¥à¸¶à¸
local SpinSpeed = 2080            -- à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§à¸«à¸¡à¸¸à¸™à¸£à¸­à¸šà¸•à¸±à¸§
local UndergroundAngle = 0        -- à¸¡à¸¸à¸¡à¸«à¸¡à¸¸à¸™

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸£à¸´à¹ˆà¸¡à¸¡à¸¸à¸”
local function StartUnderground()
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    UndergroundEnabled = true
    local initialY = hrp.Position.Y - UndergroundDepth

    local conn
    conn = RunService.RenderStepped:Connect(function(delta)
        if not UndergroundEnabled or not hrp.Parent then
            if conn then conn:Disconnect() conn = nil end
            return
        end

        UndergroundAngle = (UndergroundAngle + SpinSpeed * delta) % 360
        local rad = math.rad(UndergroundAngle)

        local offsetX = math.cos(rad) * 6 -- à¸£à¸±à¸¨à¸¡à¸µà¸§à¸‡à¸«à¸¡à¸¸à¸™ 6
        local offsetZ = math.sin(rad) * 6
        local newPos = Vector3.new(hrp.Position.X + offsetX, initialY, hrp.Position.Z + offsetZ)

        -- à¸«à¸¡à¸¸à¸™à¸«à¸±à¸™à¹„à¸›à¸ˆà¸¸à¸”à¹€à¸”à¸´à¸¡à¸à¸¥à¸²à¸‡à¸•à¸±à¸§
        hrp.CFrame = CFrame.new(newPos, Vector3.new(hrp.Position.X, initialY, hrp.Position.Z))
    end)
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸«à¸¢à¸¸à¸”à¸¡à¸¸à¸”
local function StopUnderground()
    UndergroundEnabled = false
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸£à¸§à¸ˆ Anti Ragdoll (à¹„à¸¡à¹ˆà¸¥à¹‰à¸¡)
local function AntiRagdoll()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return end
    if humanoid.PlatformStand then
        humanoid.PlatformStand = false
        humanoid.Sit = false
        hrp.Velocity = Vector3.new(0,0,0)
        hrp.RotVelocity = Vector3.new(0,0,0)
    end
end

-- à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChild("Humanoid")
    if not humanoid then return end

    -- Underground Auto
    if UndergroundAutoEnabled then
        if humanoid.Health < 16 and humanoid.Health > 0 then
            if not UndergroundEnabled then StartUnderground() end
        elseif humanoid.Health >= 30 or humanoid.Health <= 0 then
            if UndergroundEnabled then StopUnderground() end
        end
    end

    -- Anti Ragdoll
    AntiRagdoll()
end)

-- Toggle à¸›à¸¸à¹ˆà¸¡ UI
CheaterTab:Toggle({
    Title = "Anti Kill",
    Value = UndergroundAutoEnabled,
    Callback = function(state)
        UndergroundAutoEnabled = state
        if not state then UndergroundEnabled = false end
    end
})

Players.LocalPlayer.CharacterAdded:Connect(function(char)
    if UndergroundAutoEnabled then
        UndergroundEnabled = false
    end
end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local CounterTable

-- à¸«à¸² CounterTable
local function findCounter()
    for _, obj in ipairs(getgc(true)) do
        if typeof(obj) == "table" and rawget(obj, "event") and rawget(obj, "func") then
            return obj
        end
    end
    return nil
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸£à¸´à¹ˆà¸¡ Anti Ragdoll
local function startAntiRagdoll()
    CounterTable = findCounter()
    if not CounterTable then
        warn("âŒ à¹„à¸¡à¹ˆà¸žà¸š CounterTable!")
        return
    end

    spawn(function()
        while AntiRagdollEnabled do
            CounterTable.event = (CounterTable.event or 0) + 1
            local SendRemote = ReplicatedStorage.Remotes:WaitForChild("Send")
            pcall(function()
                SendRemote:FireServer(CounterTable.event, "end_ragdoll_early")
            end)
            wait(0.3)

            if AntiRagdollEnabled then
                CounterTable.event = (CounterTable.event or 0) + 1
                pcall(function()
                    SendRemote:FireServer(CounterTable.event, "clear_ragdoll")
                end)
            end
            wait(0.3)
        end
    end)
end

-- WindUI Toggle
CheaterTab:Toggle({
    Title = "Anti Ragdoll",
    Value = AntiRagdollEnabled,
    Callback = function(state)
        AntiRagdollEnabled = state
        if AntiRagdollEnabled then
            startAntiRagdoll()
            print("âœ… Anti Ragdoll ON")
        else
            print("âŒ Anti Ragdoll OFF")
        end
    end
})

-- Auto start à¹€à¸¡à¸·à¹ˆà¸­ respawn
player.CharacterAdded:Connect(function()
    if AntiRagdollEnabled then
        wait(1)
        startAntiRagdoll()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local rootPart = char:WaitForChild("HumanoidRootPart")

-- à¹€à¸à¹‡à¸šà¸ªà¸–à¸²à¸™à¸° Toggle à¹„à¸§à¹‰
local PickupEnabled = false

-- à¸«à¸² CounterTable
local CounterTable
pcall(function()
    for _, Obj in ipairs(getgc(true)) do
        if typeof(Obj) == "table" and rawget(Obj, "event") and rawget(Obj, "func") then
            CounterTable = Obj
            break
        end
    end
end)

-- NetGet Function
local function NetGet(...)
    if not CounterTable or not CounterTable.func then return end
    local args = {...}
    CounterTable.func = (CounterTable.func or 0) + 1
    local success, result = pcall(function()
        local GetRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Get")
        return GetRemote:InvokeServer(CounterTable.func, unpack(args))
    end)
    if not success then warn("[NetGet Error]", result) end
    return result
end

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹à¸¥à¸°à¹€à¸à¹‡à¸šà¹„à¸­à¹€à¸—à¹‡à¸¡
local function CheckAndPickup()
    if not PickupEnabled then return end
    if not rootPart or not rootPart.Parent then return end

    local droppedFolder = workspace:FindFirstChild("DroppedItems") or workspace:FindFirstChild("DroppedItem")
    if not droppedFolder then return end

    for _, item in ipairs(droppedFolder:GetChildren()) do
        if item.Name == "Money" then continue end
        if item:IsA("Model") and item:FindFirstChildWhichIsA("BasePart") then
            local success, modelCF = pcall(function()
                return (item.GetPivot and item:GetPivot() or item:GetModelCFrame())
            end)
            if not success or not modelCF then continue end
            local distance = (rootPart.Position - modelCF.Position).Magnitude
            if distance <= 15 then
                pcall(function()
                    NetGet("pickup_dropped_item", item)
                end)
            end
        end
    end
end

-- à¸­à¸±à¸›à¹€à¸”à¸• char à¹ƒà¸«à¸¡à¹ˆà¹€à¸¡à¸·à¹ˆà¸­ Spawn / à¸•à¸²à¸¢
local function UpdateChar(newChar)
    char = newChar
    rootPart = char:WaitForChild("HumanoidRootPart")
end

player.CharacterAdded:Connect(UpdateChar)
if char then
    UpdateChar(char)
end

-- Loop à¸—à¸¸à¸à¹€à¸Ÿà¸£à¸¡
RunService.Heartbeat:Connect(CheckAndPickup)

-- WindUI Toggle
CheaterTab:Toggle({
    Title = "Pickup Items",
    Value = PickupEnabled,
    Callback = function(state)
        PickupEnabled = state
        print("ðŸ§² Auto Pickup Items:", state and "ON" or "OFF")
    end
})

local replicated = game:GetService("ReplicatedStorage")
local SprintModule = require(replicated.Modules.Game.Sprint)
local consume_stamina = SprintModule.consume_stamina
local SprintBar = debug.getupvalue(consume_stamina, 2).sprint_bar

-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ global à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸Šà¹‡à¸„à¸„à¹ˆà¸²
local function c()
    return getgenv()
end

c().Infinitestamina = false -- à¹€à¸£à¸´à¹ˆà¸¡à¸›à¸´à¸”à¸à¹ˆà¸­à¸™

-- Hook SprintBar.update
local Old
Old = hookfunction(SprintBar.update, function(...)
    if c().Infinitestamina then
        return Old(function() return 1 end)
    else
        return Old(...)
    end
end)

CheaterTab:Toggle({
    Title = "Infinite Stamina",
    Value = c().Infinitestamina,
    Callback = function(state)
        c().Infinitestamina = state
        if state then
            print("âœ… Infinite Stamina ON")
        else
            print("âŒ Infinite Stamina OFF")
        end
    end
})

CheaterTab:Divider()
CheaterTab:Section({Title="Snap PC key [ Z ]"})

local JumpEnabled = false
local SnapHeightOffset = -7
local SnapDirection = "Down"
local SnapDuration = 0.1
local SnapBlockDuration = 5

local isRunning = false

local function SnapQuick()
    if isRunning then return end
    isRunning = true

    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then isRunning=false return end

    local blocks = {}
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            local blk = Instance.new("Part")
            blk.Size = part.Size
            blk.CFrame = part.CFrame
            blk.Anchored = true
            blk.CanCollide = false
            blk.Material = Enum.Material.Neon
            blk.Transparency = 0.5
            blk.Color = Color3.fromRGB(0,170,255) -- à¸ªà¸µà¸Ÿà¹‰à¸²
            blk.Parent = workspace
            table.insert(blocks, blk)
        end
    end

    -- à¸•à¸±à¹‰à¸‡à¹€à¸§à¸¥à¸²à¹ƒà¸«à¹‰à¸¥à¸šà¸šà¸¥à¹‡à¸­à¸à¸«à¸¥à¸±à¸‡ 5 à¸§à¸´à¸™à¸²à¸—à¸µ
    task.spawn(function()
        task.wait(SnapBlockDuration)
        for _, blk in ipairs(blocks) do
            if blk and blk.Parent then blk:Destroy() end
        end
    end)

    hum.Sit = true
    local origY = hrp.Position.Y
    local offset = math.abs(SnapHeightOffset)
    if SnapDirection == "Down" then offset = -offset end

    local conn
    conn = RunService.RenderStepped:Connect(function()
        if hrp and hrp.Parent then
            hrp.CFrame = hrp.CFrame:Lerp(CFrame.new(hrp.Position.X, origY+offset, hrp.Position.Z),0.8)

            for i, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") and blocks[i] then
                    local blk = blocks[i]
                    if blk and blk.Parent then
                        blk.CFrame = part.CFrame
                    end
                end
            end
        end
    end)

    task.wait(SnapDuration)
    if conn then conn:Disconnect() conn=nil end
    hum.Sit = false
    isRunning=false
end

CheaterTab:Button({
    Title="Snap Click",
    Locked=false,
    Callback=function() SnapQuick() end
})

-- Slider Snap Depth
CheaterTab:Slider({
    Title="Snap Depth",
    Step=1,
    Value={Min=1,Max=50,Default=math.abs(SnapHeightOffset)},
    Callback=function(val)
        SnapHeightOffset=(SnapDirection=="Down" and -1 or 1)*val
    end
})

-- Dropdown Snap Direction
CheaterTab:Dropdown({
    Title="Snap Direction",
    Values={"Down","Up"},
    Value=SnapDirection,
    Callback=function(opt)
        SnapDirection=opt
        SnapHeightOffset=(opt=="Down" and -1 or 1)*math.abs(SnapHeightOffset)
    end
})

UserInputService.InputBegan:Connect(function(input,gpe)
    if gpe then return end
    if input.KeyCode==Enum.KeyCode.Z then SnapQuick() end
end)
